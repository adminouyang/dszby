name: hotel-ipæ£€æµ‹0.3ç‰ˆ
on:
 schedule:
   - cron: 0 11,23 * * *
 workflow_dispatch:

jobs:
  run-script:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v2
  
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: 3.x

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests eventlet
        pip install python-dotenv
        
    - name: hotel-ipæ£€æµ‹0.3ç‰ˆ
      run: |
       python << 'EOF'
       import os
       import re
       import requests
       import time
       import json
       import concurrent.futures
       import random
       import threading
       from datetime import datetime, timedelta
       from urllib.parse import quote, unquote
       import base64
       from queue import Queue
       import eventlet
       import sys
       
       # å¢åŠ é€’å½’æ·±åº¦é™åˆ¶
       sys.setrecursionlimit(10000)
       
       # ===============================
       # é…ç½®åŒº
       # ===============================
       # é…ç½®æ–‡ä»¶è·¯å¾„
       COOKIE_FILE = "Hotel/cookie.txt"
       
       
       # åŠ è½½FOFA Cookieçš„å‡½æ•°
       def load_fofa_cookie():
           """ä»å¤–éƒ¨æ–‡ä»¶åŠ è½½FOFA Cookie"""
           cookie = ""
       
           # é¦–å…ˆå°è¯•ä»cookie.txtæ–‡ä»¶è¯»å–
           if os.path.exists(COOKIE_FILE):
               try:
                   with open(COOKIE_FILE, 'r', encoding='utf-8') as f:
                       cookie = f.read().strip()
                   if cookie:
                       print("âœ… ä»cookie.txtæ–‡ä»¶åŠ è½½FOFA CookieæˆåŠŸ")
                       return cookie
               except Exception as e:
                   print(f"âŒ è¯»å–cookie.txtæ–‡ä»¶å¤±è´¥: {e}")
           # å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨æˆ–è¯»å–å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤Cookie
           default_cookie = ""
       
           print("âš ï¸ ä½¿ç”¨é»˜è®¤FOFA Cookieï¼Œå»ºè®®æ›´æ–°ä¸ºæœ‰æ•ˆçš„Cookie")
           return default_cookie
       
       
       # åŠ è½½FOFA Cookie
       FOFA_COOKIE = load_fofa_cookie()
       
       # æœç´¢å…³é”®è¯
       SEARCH_QUERIES = [
           '"ZHGXTV" && country="CN"',
           '"iptv/live/zh_cn.js" && country="CN"',
       ]
       
       # IPå­˜å‚¨ç›®å½•
       IP_DIR = "Hotel/ip"
       if not os.path.exists(IP_DIR):
           os.makedirs(IP_DIR)
       
       # é¢‘é“æ–‡ä»¶è¾“å‡ºç›®å½•
       CHANNEL_DIR = "Hotel"
       if not os.path.exists(CHANNEL_DIR):
           os.makedirs(CHANNEL_DIR)
       
       # æµ‹é€Ÿé˜ˆå€¼ (MB/s)
       SPEED_THRESHOLD = 0.5
       
       # User-Agentåˆ—è¡¨
       USER_AGENTS = [
           'Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11',
           'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:117.0) Gecko/20100101 Firefox/117.0',
           'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.5845.179 Safari/537.36 Edg/116.0.1938.69',
           'Mozilla/5.0 (Macintosh; Intel Mac OS X 12_6_3) AppleWebKit/537.36 (KHTML, like Gecko) Version/15.6 Safari/537.36',
           'Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1',
           'Mozilla/5.0 (Linux; Android 12; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.5845.179 Mobile Safari/537.36',
           'Mozilla/5.0 (Android 12; Mobile; rv:117.0) Gecko/117.0 Firefox/117.0',
           'Mozilla/5.0 (compatible; bingbot/2.0; +http://www.bing.com/bingbot.htm)',
           'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)',
           'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.5845.179 Safari/537.36',
           'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:117.0) Gecko/20100101 Firefox/117.0',
           'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/116.0.5845.179 Chrome/116.0.5845.179 Safari/537.36',
           'Mozilla/5.0 (compatible; Konqueror/4.14; Linux) KHTML/4.14.2 (like Gecko)',
           "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Epiphany/42.3 Safari/537.36",
           "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.5845.179 Safari/537.36 OPR/103.0.4928.47",
           "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
           "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0"
       ]
       
       # çœä»½å«è§†æ˜ å°„
       PROVINCE_TV_MAP = {
           "åŒ—äº¬": "åŒ—äº¬å«è§†", "å¤©æ´¥": "å¤©æ´¥å«è§†", "æ²³åŒ—": "æ²³åŒ—å«è§†", "å±±è¥¿": "å±±è¥¿å«è§†", "å†…è’™å¤": "å†…è’™å¤å«è§†",
           "è¾½å®": "è¾½å®å«è§†", "å‰æ—": "å‰æ—å«è§†", "é»‘é¾™æ±Ÿ": "é»‘é¾™æ±Ÿå«è§†", "ä¸Šæµ·": "ä¸Šæµ·å«è§†", "æ±Ÿè‹": "æ±Ÿè‹å«è§†",
           "æµ™æ±Ÿ": "æµ™æ±Ÿå«è§†", "å®‰å¾½": "å®‰å¾½å«è§†", "ç¦å»º": "ä¸œå—å«è§†", "æ±Ÿè¥¿": "æ±Ÿè¥¿å«è§†", "å±±ä¸œ": "å±±ä¸œå«è§†",
           "æ²³å—": "æ²³å—å«è§†", "æ¹–åŒ—": "æ¹–åŒ—å«è§†", "æ¹–å—": "æ¹–å—å«è§†", "å¹¿ä¸œ": "å¹¿ä¸œå«è§†", "å¹¿è¥¿": "å¹¿è¥¿å«è§†",
           "æµ·å—": "æµ·å—å«è§†", "é‡åº†": "é‡åº†å«è§†", "å››å·": "å››å·å«è§†", "è´µå·": "è´µå·å«è§†", "äº‘å—": "äº‘å—å«è§†",
           "è¥¿è—": "è¥¿è—å«è§†", "é™•è¥¿": "é™•è¥¿å«è§†", "ç”˜è‚ƒ": "ç”˜è‚ƒå«è§†", "é’æµ·": "é’æµ·å«è§†", "å®å¤": "å®å¤å«è§†",
           "æ–°ç–†": "æ–°ç–†å«è§†",
       }
       
       # é¢‘é“åˆ†ç±»å®šä¹‰
       CHANNEL_CATEGORIES = {
           "å¤®è§†é¢‘é“": [
               "CCTV1", "CCTV2", "CCTV3", "CCTV4", "CCTV4æ¬§æ´²", "CCTV4ç¾æ´²", "CCTV5", "CCTV5+", "CCTV6", "CCTV7",
               "CCTV8", "CCTV9", "CCTV10", "CCTV11", "CCTV12", "CCTV13", "CCTV14", "CCTV15", "CCTV16", "CCTV17",
               "å…µå™¨ç§‘æŠ€", "é£äº‘éŸ³ä¹", "é£äº‘è¶³çƒ", "é£äº‘å‰§åœº", "æ€€æ—§å‰§åœº", "ç¬¬ä¸€å‰§åœº", "å¥³æ€§æ—¶å°š", "ä¸–ç•Œåœ°ç†", "å¤®è§†å°çƒ", "é«˜å°”å¤«ç½‘çƒ",
               "å¤®è§†æ–‡åŒ–ç²¾å“", "å«ç”Ÿå¥åº·", "ç”µè§†æŒ‡å—", "è€æ•…äº‹", "ä¸­å­¦ç”Ÿ", "å‘ç°ä¹‹æ—…", "ä¹¦ç”»", "å›½å­¦é¢‘é“", "ç¯çƒå¥‡è§‚",
               "CETV1", "CETV2", "CETV3", "CETV4", "æ—©æœŸæ•™è‚²", "CGTNçºªå½•",
           ],
           "å«è§†é¢‘é“": [
               "é‡æ¸©ç»å…¸", "æ¹–å—å«è§†", "æµ™æ±Ÿå«è§†", "æ±Ÿè‹å«è§†", "ä¸œæ–¹å«è§†", "æ·±åœ³å«è§†", "åŒ—äº¬å«è§†", "å¹¿ä¸œå«è§†", "å¹¿è¥¿å«è§†", "ä¸œå—å«è§†", "æµ·å—å«è§†",
               "æ²³åŒ—å«è§†", "æ²³å—å«è§†", "æ¹–åŒ—å«è§†", "æ±Ÿè¥¿å«è§†", "å››å·å«è§†", "é‡åº†å«è§†", "è´µå·å«è§†", "äº‘å—å«è§†", "å¤©æ´¥å«è§†", "å®‰å¾½å«è§†", "å¦é—¨å«è§†",
               "å±±ä¸œå«è§†", "è¾½å®å«è§†", "é»‘é¾™æ±Ÿå«è§†", "å‰æ—å«è§†", "å†…è’™å¤å«è§†", "å®å¤å«è§†", "å±±è¥¿å«è§†", "é™•è¥¿å«è§†", "ç”˜è‚ƒå«è§†", "é’æµ·å«è§†",
               "æ–°ç–†å«è§†", "è¥¿è—å«è§†", "ä¸‰æ²™å«è§†", "å…µå›¢å«è§†", "å»¶è¾¹å«è§†", "å®‰å¤šå«è§†", "åº·å·´å«è§†", "å†œæ—å«è§†", "å±±ä¸œæ•™è‚²å«è§†","å¤§æ¹¾åŒºå«è§†",
           ],
           "æ•°å­—é¢‘é“": [
               "CHCåŠ¨ä½œç”µå½±", "CHCå®¶åº­å½±é™¢", "CHCå½±è¿·ç”µå½±", "æ·˜ç”µå½±", "æ·˜ç²¾å½©", "æ·˜å‰§åœº", "æ·˜4K", "æ·˜å¨±ä¹",
               "4Kç”µå½±","æµ·çœ‹å¤§ç‰‡", "ç»å…¸ç”µå½±", "ç²¾å½©å½±è§†", "å–œå‰§å½±é™¢", "åŠ¨ä½œå½±é™¢", "ç²¾å“å‰§åœº","æŠ—æˆ˜å‰§åœº", "IPTVæˆæ›²", "æ±‚ç´¢çºªå½•", "æ±‚ç´¢ç§‘å­¦", "æ³•åˆ¶å¤©åœ°",
               "æ±‚ç´¢ç”Ÿæ´»", "æ±‚ç´¢åŠ¨ç‰©", "çºªå®äººæ–‡", "é‡‘é¹°çºªå®", "çºªå®ç§‘æ•™", "ç›å½©é’å°‘", "ç›å½©ç«æŠ€", "ç›å½©ç¯®çƒ", "ç›å½©å¹¿åœºèˆ", "é­…åŠ›è¶³çƒ", "äº”æ˜Ÿä½“è‚²", "ä½“è‚²èµ›äº‹",
               "åŠ²çˆ†ä½“è‚²", "å¿«ä¹å‚é’“", "å››æµ·é’“é±¼", "èŒ¶é¢‘é“", "å…ˆé”‹ä¹’ç¾½", "å¤©å…ƒå›´æ£‹", "æ±½æ‘©", "è½¦è¿·é¢‘é“", "æ¢¨å›­é¢‘é“", "æ–‡ç‰©å®åº“", "æ­¦æœ¯ä¸–ç•Œ",
               "ä¹æ¸¸", "ç”Ÿæ´»æ—¶å°š", "éƒ½å¸‚å‰§åœº", "æ¬¢ç¬‘å‰§åœº",
               "ä¸­å›½äº¤é€š", "ä¸­å›½å¤©æ°”", "ç½‘ç»œæ£‹ç‰Œ","EETVç”Ÿæ€ç¯å¢ƒ",
           ],
           "å°‘å„¿é¢‘é“": [
                "æ·˜BABY","æ·˜èŒå® ", "é‡‘è‰²å­¦å ‚", "åŠ¨æ¼«ç§€åœº", "æ–°åŠ¨æ¼«", "é‡‘é¹°å¡é€š", "ä¼˜æ¼«å¡é€š", "å“ˆå“ˆç‚«åŠ¨", "å˜‰ä½³å¡é€š","ä¼˜ä¼˜å®è´",
           ],
           "æ¸¯æ¾³å°é¢‘é“": [
               "å‡¤å‡°å«è§†ä¸­æ–‡å°", "å‡¤å‡°å«è§†èµ„è®¯å°", "å‡¤å‡°å«è§†é¦™æ¸¯å°", "å‡¤å‡°å«è§†ç”µå½±å°", "é¾™ç¥¥æ—¶ä»£", "æ˜Ÿç©ºå«è§†", "CHANNEL[V]", "æ¾³é—¨è²èŠ±", "TVBæ˜Ÿæ²³", "ä¸œæ£®è´¢ç»æ–°é—»",
               "ä¸œæ£®ç»¼åˆ", "ç§äººå½±é™¢", "DMAX", "åŠ¨ç‰©æ˜Ÿçƒ", "ANIMAX",
           ],
           "å®‰å¾½é¢‘é“": [
               "å®‰å¾½å½±è§†", "å®‰å¾½ç»æµç”Ÿæ´»", "å®‰å¾½å…¬å…±", "å®‰å¾½ç»¼è‰ºä½“è‚²", "å®‰å¾½å†œä¸šç§‘æ•™", "é˜œé˜³å…¬å…±é¢‘é“", "é©¬éå±±æ–°é—»ç»¼åˆ", "é©¬éå±±å…¬å…±", "", "", "", "ç¯çƒå¥‡è§‚",
               "ä¸´æ³‰ä¸€å°", "", "", "", "", "", "", "",
               "", "", "", "", "", "", "", "", "", "", "",
           ],
           "åŒ—äº¬é¢‘é“": [
               "åŒ—äº¬æ–°é—»","åŒ—äº¬å½±è§†","åŒ—äº¬çºªå®ç§‘æ•™", "åŒ—äº¬è´¢ç»", "åŒ—äº¬æ–‡è‰º","åŒ—äº¬ä½“è‚²ä¼‘é—²", "", "", "", "åŒ—äº¬å¡é…·å°‘å„¿",
           ],
           "ä¸Šæµ·é¢‘é“": [
               "æ–°é—»ç»¼åˆ", "éƒ½å¸‚é¢‘é“", "ä¸œæ–¹å½±è§†", "çºªå®äººæ–‡", "ç¬¬ä¸€è´¢ç»", "äº”æ˜Ÿä½“è‚²", "ä¸œæ–¹è´¢ç»", "ICSé¢‘é“", "ä¸Šæµ·æ•™è‚²å°", "ä¸ƒå½©æˆå‰§", "æ³•æ²»å¤©åœ°", "é‡‘è‰²å­¦å ‚",
               "åŠ¨æ¼«ç§€åœº", "æ¬¢ç¬‘å‰§åœº4K", "ç”Ÿæ´»æ—¶å°š", "", "", "", "", "",
               "", "", "", "", "", "", "", "", "", "", "",
           ],
           "æ¹–å—é¢‘é“": [
               "æ¹–å—å›½é™…é¢‘é“", "æ¹–å—ç”µå½±", "æ¹–å—ç”µè§†å‰§", "æ¹–å—ç»è§†", "æ¹–å—å¨±ä¹", "æ¹–å—å…¬å…±", "æ¹–å—éƒ½å¸‚", "æ¹–å—æ•™è‚²", "èŠ’æœäº’å¨±", "é•¿æ²™æ–°é—»", "é•¿æ²™æ”¿æ³•", "é•¿æ²™å½±è§†", "é•¿æ²™å¥³æ€§", "",
               "ç›Šé˜³å…¬å…±", "æŠ—æˆ˜å‰§åœº", "å¤è£…å‰§åœº", "é«˜æ¸…é™¢çº¿", "å…ˆé”‹å…µç¾½", "æœ›åŸç»¼åˆ", "èŠ±é¼“æˆ", "",
               "", "", "", "", "", "", "", "", "", "", "",
           ],
           "æ¹–åŒ—é¢‘é“": [
               "æ¹–åŒ—ç»¼åˆ", "æ¹–åŒ—å½±è§†", "æ¹–åŒ—ç”Ÿæ´»", "æ¹–åŒ—å…¬å…±æ–°é—»", "æ¹–åŒ—æ•™è‚²", "æ¹–åŒ—ç»è§†", "è†å·æ–°é—»", "è†å·å„ä¸Š", "", "", "", "", "", "", "", "",
           ],
           "æ²³å—é¢‘é“": [
               "æ²³å—æ–°é—»é¢‘é“","æ²³å—ç”µè§†å‰§é¢‘é“", "æ²³å—éƒ½å¸‚é¢‘é“", "æ²³å—æ°‘ç”Ÿé¢‘é“", "æ²³å—æ³•æ²»é¢‘é“", "æ²³å—å…¬å…±é¢‘é“", "", "", "", "", "", "", "", "", "",
           ],
           "æ²³åŒ—é¢‘é“": [
               "æ²³åŒ—å½±è§†å‰§", "æ²³åŒ—éƒ½å¸‚", "æ²³åŒ—ç»æµç”Ÿæ´»", "æ²³åŒ—æ–‡æ—…å…¬å…±", "æ²³åŒ—å°‘å„¿ç§‘æ•™", "æ²³åŒ—ä¸‰å†œ", "è¡¡æ°´æ–°é—»ç»¼åˆ", "è¡¡æ°´ç»æµç§‘æ•™", "çŸ³å®¶åº„å¨±ä¹", "çŸ³å®¶åº„æ–°é—»ç»¼åˆ", "çŸ³å®¶åº„ç”Ÿæ´»", "", "", "",
           ],
           "å±±ä¸œé¢‘é“": [
               "å±±ä¸œç»¼è‰º", "å±±ä¸œå½±è§†", "å±±ä¸œé½é²", "å±±ä¸œå†œç§‘", "å±±ä¸œä½“è‚²", "å±±ä¸œç”Ÿæ´»", "å±±ä¸œå°‘å„¿", "çƒŸå°æ–°é—»", "å±±ä¸œæ•™è‚²", "ä¸´æ²‚å¯¼è§†", "ä¸´æ²‚å›¾æ–‡", "ä¸´æ²‚ç»¼åˆ", "ä¸´æ²‚å†œç§‘", "å…°é™µå¯¼è§†",
               "å…°é™µå…¬å…±", "å…°é™µç»¼åˆ",
           ],
           "å¹¿ä¸œé¢‘é“": [
               "å¹¿ä¸œå½±è§†", "å¹¿ä¸œå°‘å„¿", "å¹¿ä¸œæ°‘ç”Ÿ", "å¹¿ä¸œæ–°é—»", "", "", "å¹¿ä¸œç»æµç§‘æ•™", "å¹¿ä¸œä½“è‚²", "å¹¿å·æ–°é—»", "å¹¿ä¸œç æ±Ÿ","å¹¿ä¸œå²­å—æˆæ›²", "æ·±åœ³éƒ½å¸‚", "æ·±åœ³å°‘å„¿", "å˜‰ä½³å¡é€š", "èŒ‚åç»¼åˆ", "", "",
           ],
           "å¹¿è¥¿é¢‘é“": [
               "å¹¿è¥¿å½±è§†","å¹¿è¥¿æ–°é—»", "å¹¿è¥¿ç»¼è‰º", "å¹¿è¥¿éƒ½å¸‚", "", "å¹¿è¥¿ç§»åŠ¨", "å¹¿è¥¿ç§‘æŠ€", "ç²¾å½©å½±è§†", "å¹³å—å°","å—å®æ–°é—»ç»¼åˆ", "å—å®å½±è§†å¨±ä¹", "å—å®å…¬å…±", "ç‰æ—æ–°é—»ç»¼åˆ","å›¾æ–‡ä¿¡æ¯", "å…´ä¸šç»¼åˆ", "", "", "", "", "", "",
           ],
           "å››å·é¢‘é“": [
               "å››å·æ–°é—»", "å››å·æ–‡åŒ–æ—…æ¸¸", "å››å·å½±è§†æ–‡è‰º", "å³¨çœ‰ç”µå½±", "ç†ŠçŒ«å½±é™¢", "å¹¿å…ƒç»¼åˆ", "å¹¿å…ƒå…¬å…±", "å››å·å«è§†-ä¹¡æ‘å…¬å…±", "è“¬å®‰ç”µè§†å°", "", "", "", "", "", "", "",
               "é‡‘ç†ŠçŒ«å¡é€š",
           ],
           "æ±Ÿè¥¿é¢‘é“": [
               "æ±Ÿè¥¿æ•™è‚²", "æ±Ÿè¥¿æŒ‡å—", "æŠšå·ç»¼åˆ", "JXTV2", "JXTV3", "JXTV4", "JXTV5", "ç« è´¡TV", "èµ£å·TV1", "èµ£å·TVå…¬å…±", "èµ£å·TVæ•™è‚²", "", "", "", "",
               "", "",
           ],
           "é™•è¥¿é¢‘é“": [
               "é™•è¥¿æ–°é—»èµ„è®¯", "é™•è¥¿éƒ½å¸‚é’æ˜¥", "", "", "", "", "", "", "ä¸‰é—¨å³¡æ–°é—»ç»¼åˆ", "çµå®æ–°é—»ç»¼åˆ", "", "", "", "", "", "", "",
           ],
           "æµ™æ±Ÿé¢‘é“": [
               "æµ™æ±Ÿæ–°é—»", "æ­å·å½±è§†", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
           ],
           "å‰æ—é¢‘é“": [
               "å‰æ—å½±è§†", "å‰æ—éƒ½å¸‚", "å‰æ—ä¹¡æ‘", "å‰æ—æ•™è‚²", "å‰æ—ç»¼è‰º", "å‰æ—ç”Ÿæ´»", "", "", "é•¿å½±é¢‘é“", "æ¾åŸå…¬å…±", "æ¾åŸ", "", "", "", "", "", "",
           ],
           "é»‘é¾™æ±Ÿé¢‘é“": [
               "é»‘é¾™æ±Ÿå½±è§†", "é»‘é¾™æ±Ÿæ–‡ä½“", "é»‘é¾™æ±Ÿéƒ½å¸‚", "é»‘é¾™æ±Ÿæ–°é—»æ³•æ²»", "é»‘é¾™æ±Ÿå…¬å…±", "é»‘é¾™æ±Ÿå°‘å„¿", "", "", "", "", "", "", "", "", "", "", "",
           ],
           "æ–°ç–†é¢‘é“": [
               "æ–°ç–†2", "æ–°ç–†3", "æ–°ç–†4", "æ–°ç–†5", "æ–°ç–†6", "æ–°ç–†7", "æ–°ç–†8", "æ–°ç–†9", "", "", "", "", "", "", "", "", "",
           ],
           "å…¶ä»–é¢‘é“": []
       }
       
       # ç‰¹æ®Šç¬¦å·æ˜ å°„
       SPECIAL_SYMBOLS = ["HD", "LT", "XF", "-", "_", " ", "", "Â·", "é«˜æ¸…", "æ ‡æ¸…", "è¶…æ¸…", "H265", "4K", "FHD", "HDTV"]
       
       # é¢‘é“åç§°æ˜ å°„
       CHANNEL_MAPPING = {
           "CCTV1": ["CCTV-1", "CCTV1ç»¼åˆ", "CCTV1-ç»¼åˆ","CCTV1-ç»¼åˆHD", "CCTV1-ç»¼åˆé«˜æ¸…","CCTV1é«˜æ¸…", "CCTV1HD", "cctv1", "ä¸­å¤®1å°", "sCCTV1-ç»¼åˆ", "CCTV01"],
           "CCTV2": ["CCTV-2", "CCTV2è´¢ç»", "CCTV2-è´¢ç»","CCTV2-è´¢ç»HD", "CCTV2-è´¢ç»é«˜æ¸…", "CCTV2é«˜æ¸…", "CCTV2HD", "cctv2", "ä¸­å¤®2å°", "aCCTV2", "sCCTV2-è´¢ç»", "CCTV02"],
           "CCTV3": ["CCTV-3", "CCTV3ç»¼è‰º", "CCTV3-ç»¼è‰º","CCTV3-ç»¼è‰ºHD", "CCTV3-ç»¼è‰ºé«˜æ¸…", "CCTV3é«˜æ¸…", "CCTV3HD", "cctv3", "ä¸­å¤®3å°", "acctv3", "sCCTV3-ç»¼è‰º", "CCTV03"],
           "CCTV4": ["CCTV-4", "CCTV4ä¸­æ–‡å›½é™…","CCTV4-å›½é™…","CCTV4å›½é™…", "CCTV4-å›½é™…é«˜æ¸…", "CCTV4é«˜æ¸…", "CCTV4HD", "cctv4", "ä¸­å¤®4å°", "aCCTV4", "sCCTV4-å›½é™…", "CCTV04",],
           "CCTV5": ["CCTV-5", "CCTV5ä½“è‚²", "CCTV5-ä½“è‚²","CCTV5-ä½“è‚²HD", "CCTV5-ä½“è‚²é«˜æ¸…","CCTV5é«˜æ¸…", "CCTV5HD", "cctv5", "ä¸­å¤®5å°", "sCCTV5-ä½“è‚²", "CCTV05"],
           "CCTV5+": ["CCTV-5+", "CCTV5+ä½“è‚²èµ›äº‹","CCTV5+ä½“è‚²", "CCTV5+ä½“è‚²èµ›äº‹é«˜æ¸…", "CCTV5+é«˜æ¸…", "CCTV5+HD", "cctv5+", "CCTV5plus"],
           "CCTV6": ["CCTV-6", "CCTV6ç”µå½±", "CCTV6-ç”µå½±","CCTV6-ç”µå½±HD", "CCTV6é«˜æ¸…", "CCTV6HD", "cctv6", "ä¸­å¤®6å°", "sCCTV6-ç”µå½±", "CCTV06"],
           "CCTV7": ["CCTV-7","CCTV7å›½é˜²å†›äº‹", "CCTV7å†›äº‹","CCTV7-å†›å†œ","CCTV7å†›äº‹å†œä¸š", "CCTV7-å›½é˜²å†›äº‹é«˜æ¸…", "CCTV7é«˜æ¸…", "CCTV7HD", "cctv7", "ä¸­å¤®7å°", "CCTV07",],
           "CCTV8": ["CCTV-8", "CCTV8ç”µè§†å‰§", "CCTV8-ç”µè§†å‰§","CCTV8-ç”µè§†å‰§HD","CCTV8-ç”µè§†å‰§é«˜æ¸…", "CCTV8é«˜æ¸…", "CCTV8HD", "cctv8", "ä¸­å¤®8å°", "sCCTV8-ç”µè§†å‰§", "CCTV08"],
           "CCTV9": ["CCTV-9", "CCTV9çºªå½•","CCTV9è®°å½•", "CCTV9-çºªå½•", "CCTV9-çºªå½•é«˜æ¸…","CCTV9é«˜æ¸…", "CCTV9HD", "cctv9", "ä¸­å¤®9å°", "sCCTV9-çºªå½•", "CCTV09"],
           "CCTV10": ["CCTV-10", "CCTV10ç§‘æ•™", "CCTV10-ç§‘æ•™", "CCTV10-ç§‘æ•™é«˜æ¸…","CCTV10é«˜æ¸…", "CCTV10HD", "cctv10", "ä¸­å¤®10å°", "sCCTV10-ç§‘æ•™"],
           "CCTV11": ["CCTV-11", "CCTV11æˆæ›²", "CCTV11-æˆæ›²", "CCTV11-æˆæ›²é«˜æ¸…","CCTV11é«˜æ¸…", "CCTV11HD", "cctv11", "ä¸­å¤®11å°", "sCCTV11-æˆæ›²"],
           "CCTV12": ["CCTV-12", "CCTV12ç¤¾ä¼šä¸æ³•", "CCTV12-ç¤¾ä¼šä¸æ³•", "CCTV-12ç¤¾ä¼šä¸æ³• é«˜æ¸…","CCTV12é«˜æ¸…", "CCTV12HD", "cctv12", "ä¸­å¤®12å°", "sCCTV12-ç¤¾ä¼šä¸æ³•"],
           "CCTV13": ["CCTV-13", "CCTV13æ–°é—»", "CCTV13-æ–°é—»", "CCTV13-æ–°é—»HD", "CCTV13é«˜æ¸…", "CCTV13HD", "cctv13", "ä¸­å¤®13å°", "sCCTV13-æ–°é—»","æµ‹è¯•é¢‘é“08"],
           "CCTV14": ["CCTV-14", "CCTV14å°‘å„¿", "CCTV14-å°‘å„¿", "CCTV14-å°‘å„¿ é«˜æ¸…","CCTV14é«˜æ¸…", "CCTV14HD", "cctv14", "ä¸­å¤®14å°", "sCCTV14-å°‘å„¿"],
           "CCTV15": ["CCTV-15", "CCTV15éŸ³ä¹", "CCTV15-éŸ³ä¹", "CCTV15-éŸ³ä¹é«˜æ¸…","CCTV15é«˜æ¸…", "CCTV15HD", "cctv15", "ä¸­å¤®15å°", "sCCTV15-éŸ³ä¹"],
           "CCTV16": ["CCTV-16", "CCTV16å¥¥æ—åŒ¹å…‹", "CCTV-16 å¥¥æ—åŒ¹å…‹", "CCTV-16-å¥¥è¿åŒ¹å…‹ é«˜æ¸…","CCTV16é«˜æ¸…", "CCTV16HD", "cctv16", "ä¸­å¤®16å°"],
           "CCTV17": ["CCTV-17", "CCTV17å†œä¸šå†œæ‘", "CCTV-17å†œä¸šå†œæ‘ é«˜æ¸…", "CCTV17é«˜æ¸…", "CCTV17HD", "cctv17", "ä¸­å¤®17å°"],
       
           "ç¬¬ä¸€å‰§åœº": ["CCTVç¬¬ä¸€å‰§åœº", ""],
           "é£äº‘å‰§åœº": ["CCTVé£äº‘å‰§åœº", ""],
           "æ€€æ—§å‰§åœº": ["CCTVæ€€æ—§å‰§åœº", ""],
           "é£äº‘éŸ³ä¹": ["CCTVé£äº‘éŸ³ä¹", ""],
           "ä¹¦ç”»": ["ä¹¦ç”»é¢‘é“", ""],
           "CETV1": ["CETV-1é«˜æ¸…","æ•™è‚²ä¸€å¥—",],
           "ä¸­å›½å¤©æ°”": ["ä¸­å›½æ°”è±¡"],
           "CHCåŠ¨ä½œç”µå½±": ["åŠ¨ä½œç”µå½±","åŠ¨ä½œç”µå½± é«˜æ¸…",],
           "CHCå®¶åº­å½±é™¢": ["å®¶åº­å½±é™¢","å®¶åº­å½±é™¢ é«˜æ¸…",],
           "CHCå½±è¿·ç”µå½±": ["é«˜æ¸…ç”µå½±"],
           
           "4Kç”µå½±": ["4Kç”µå½± é«˜æ¸…"],
       
       
       
           "æµ™æ±Ÿå«è§†": ["æµ™æ±Ÿå«è§†", "æµ™æ±Ÿå«è§†é«˜æ¸…","æµ™æ±Ÿå«è§†HD"],
           "åŒ—äº¬å«è§†": ["åŒ—äº¬å«è§†", "åŒ—äº¬å«è§†HD", "åŒ—äº¬å«è§†é«˜æ¸…"],
           "æ¹–å—å«è§†": ["æ¹–å—å«è§†", "æ¹–å—ç”µè§†","æ¹–å—å«è§†HD"],
           "æ±Ÿè‹å«è§†": ["æ±Ÿè‹å«è§†", "æ±Ÿè‹å«è§†HD", "æ±Ÿè‹å«è§†é«˜æ¸…"],
           "ä¸œæ–¹å«è§†": ["ä¸œæ–¹å«è§†é«˜æ¸…", "ä¸Šæµ·å«è§†", "SBN","ä¸œæ–¹å«è§†HD",],
           "å®‰å¾½å«è§†": ["å®‰å¾½å«è§†HD", "å®‰å¾½å«è§†é«˜æ¸…","å®‰å¾½å«è§† é«˜æ¸…"],
           "å±±ä¸œå«è§†": ["å±±ä¸œå«è§†", "å±±ä¸œé«˜æ¸…", "å±±ä¸œå«è§†é«˜æ¸…", "å±±ä¸œå«è§†HD"],
           "å¹¿ä¸œå«è§†": ["å¹¿ä¸œå«è§†HD", "å¹¿ä¸œå«è§†é«˜æ¸…"],
           "æ·±åœ³å«è§†": ["æ·±åœ³å«è§†HD", "æ·±åœ³å«è§†é«˜æ¸…", "æ·±åœ³"],
           "å¤©æ´¥å«è§†": ["å¤©æ´¥å«è§†"],
           "æ²³åŒ—å«è§†": ["æ²³åŒ—å«è§†"],
           "å±±è¥¿å«è§†": ["å±±è¥¿å«è§†"],
           "å†…è’™å¤å«è§†": ["å†…è’™å¤å«è§†", "å†…è’™å¤", "å†…è’™å«è§†"],
           "è¾½å®å«è§†": ["è¾½å®å«è§†", "è¾½å®å«è§†HD","è¾½å®å«è§† é«˜æ¸…"],
           "å‰æ—å«è§†": ["å‰æ—å«è§†"],
           "é»‘é¾™æ±Ÿå«è§†": ["é»‘é¾™æ±Ÿå«è§†HD","é»‘é¾™æ±Ÿå«è§†é«˜æ¸…"],
           "ä¸œå—å«è§†": ["ä¸œå—å«è§† é«˜æ¸…", "ç¦å»ºä¸œå—", "ç¦å»ºä¸œå—å«è§†"],
           "æ±Ÿè¥¿å«è§†": ["æ±Ÿè¥¿å«è§†","æ±Ÿè¥¿å«è§† é«˜æ¸…"],
           "æ²³å—å«è§†": ["æ²³å—å«è§†"],
           "æ¹–åŒ—å«è§†": ["æ¹–åŒ—å«è§†","æ¹–å—å«è§†é«˜æ¸…"],
           "å¹¿è¥¿å«è§†": ["å¹¿è¥¿å«è§†","å¹¿è¥¿å«è§† é«˜æ¸…"],
           "æµ·å—å«è§†": ["æµ·å—å«è§†", "æ—…æ¸¸å«è§†", "æµ·å—å«è§†HD"],
           "é‡åº†å«è§†": ["é‡åº†å«è§†"],
           "å››å·å«è§†": ["å››å·å«è§†", "å››å·å«è§†é«˜æ¸…","å››å·å«è§† é«˜æ¸…"],
           "è´µå·å«è§†": ["è´µå·å«è§† é«˜æ¸…","",],
           "äº‘å—å«è§†": ["äº‘å—å«è§†"],
           "è¥¿è—å«è§†": ["è¥¿è—å«è§†", "XZTV2"],
           "é™•è¥¿å«è§†": ["é™•è¥¿å«è§†"],
           "ç”˜è‚ƒå«è§†": ["ç”˜è‚ƒå«è§†","ç”˜è‚ƒå«è§† é«˜æ¸…"],
           "é’æµ·å«è§†": ["é’æµ·å«è§†"],
           "å®å¤å«è§†": ["å®å¤å«è§†"],
           "å¤§æ¹¾åŒºå«è§†": ["å—æ–¹å«è§†"],
           "æ–°ç–†å«è§†": ["æ–°ç–†å«è§†", "æ–°ç–†1"],
       
           "å‡¤å‡°å«è§†ä¸­æ–‡å°": ["å‡¤å‡°å«è§†ä¸­æ–‡å°", "å‡¤å‡°ä¸­æ–‡", "å‡¤å‡°å«è§†","æµ‹è¯•é¢‘é“03"],
           "å‡¤å‡°å«è§†èµ„è®¯å°": ["å‡¤å‡°å«è§†èµ„è®¯å°", "å‡¤å‡°èµ„è®¯", "å‡¤å‡°å’¨è¯¢","æµ‹è¯•é¢‘é“17"],
           "å‡¤å‡°å«è§†é¦™æ¸¯å°": ["å‡¤å‡°å«è§†é¦™æ¸¯å°", "å‡¤å‡°é¦™æ¸¯","æµ‹è¯•é¢‘é“04"],
           "å‡¤å‡°å«è§†ç”µå½±å°": ["å‡¤å‡°å«è§†ç”µå½±å°", "å‡¤å‡°ç”µå½±", "é³³å‡°è¡›è¦–é›»å½±å°"],
           "æ¾³é—¨è²èŠ±": ["æµ‹è¯•é¢‘é“19"],
           "TVBæ˜Ÿæ²³": ["æµ‹è¯•é¢‘é“01"],
           "ç»å…¸æ¸¯å‰§": ["æµ‹è¯•é¢‘é“02"],
           "æ˜Ÿç©ºå«è§†": ["æµ‹è¯•é¢‘é“05"],
           "é¾™ç¥¥æ—¶ä»£": ["æµ‹è¯•é¢‘é“0"],
           "ä¸œæ£®è´¢ç»æ–°é—»": ["æµ‹è¯•é¢‘é“07"],
           "ä¸œæ£®ç»¼åˆ": ["æµ‹è¯•é¢‘é“13"],
           "ç§äººå½±é™¢": ["æµ‹è¯•é¢‘é“10"],
           "DMAX": ["æµ‹è¯•é¢‘é“11"],
           "åŠ¨ç‰©æ˜Ÿçƒ": ["æµ‹è¯•é¢‘é“12"],
           "ANIMAX": ["æµ‹è¯•é¢‘é“14"],
           "æŠ—æˆ˜å‰§åœº": ["æµ‹è¯•é¢‘é“15"],
           "é‡æ¸©ç»å…¸": ["æµ‹è¯•é¢‘é“23"],
           
           
           "EETVç”Ÿæ€ç¯å¢ƒ": ["ç”Ÿæ€ç¯å¢ƒ"],
           
           "åŒ—äº¬æ–°é—»": ["BTVæ–°é—»"],
           "åŒ—äº¬å½±è§†": ["BTVå½±è§†"],
           "åŒ—äº¬çºªå®ç§‘æ•™": ["BTVç§‘æ•™","åŒ—äº¬ç§‘æ•™"],
           "åŒ—äº¬ä½“è‚²ä¼‘é—²": ["åŒ—äº¬ä½“è‚²ä¼‘é—²"],
           "åŒ—äº¬è´¢ç»": ["BTVåŒ—äº¬å«è§†"],
           "åŒ—äº¬æ–‡è‰º": ["BTVæ–‡è‰º"],
           "åŒ—äº¬å¡é…·å°‘å„¿": ["å¡é…·å°‘å„¿","BTVå¡é…·å°‘å„¿","å¡é…·åŠ¨ç”»"],
           
           "æ²³å—éƒ½å¸‚é¢‘é“": ["æ²³å—éƒ½å¸‚"],
           "æ²³å—æ°‘ç”Ÿé¢‘é“": ["æ²³å—æ°‘ç”Ÿ"],
           "æ²³å—æ³•æ²»é¢‘é“": ["æ²³å—æ³•æ²»"],
           "æ²³å—ç”µè§†å‰§é¢‘é“": ["æ²³å—ç”µè§†å‰§"],
           "æ²³å—æ–°é—»é¢‘é“": ["æ²³å—æ–°é—»"],
           "æ²³å—å…¬å…±é¢‘é“": ["æ²³å—å…¬å…±"],
           
           "æ²³åŒ—å½±è§†å‰§": ["æ²³åŒ—å½±è§†å‰§"],
           "æ²³åŒ—ç»æµç”Ÿæ´»": ["æ²³åŒ—ç»æµ"],
           "æ²³åŒ—éƒ½å¸‚": ["æ²³åŒ—éƒ½å¸‚"],
           "æ²³åŒ—æ–‡æ—…å…¬å…±": ["æ²³åŒ—å…¬å…±"],
           "æ²³åŒ—ä¸‰å†œ": ["æ²³åŒ—ä¸‰å†œ"],
           "è¡¡æ°´æ–°é—»ç»¼åˆ": ["è¡¡æ°´æ–°é—»"],
           "è¡¡æ°´ç»æµç§‘æ•™": ["è¡¡æ°´å…¬å…±"],
           
           "æ¹–å—å›½é™…é¢‘é“": ["æ¹–å—å›½é™…é«˜æ¸…","æ¹–å—å›½é™…é¢‘é“"],
           "æ¹–å—å¨±ä¹": ["æ¹–å—å¨±ä¹é«˜æ¸…"],
           "æ¹–å—ç”µå½±": ["æ¹–å—ç”µå½±é«˜æ¸…"],
           "æ¹–å—éƒ½å¸‚": ["æ¹–å—éƒ½å¸‚é«˜æ¸…"],
           "èŒ¶é¢‘é“": ["èŒ¶é¢‘é“é«˜æ¸…"],
           "é‡‘é¹°å¡é€š": ["æ¹–å—é‡‘é¹°å¡é€šé«˜æ¸…"],
           
           "æ¹–åŒ—å…¬å…±æ–°é—»": ["æ¹–åŒ—å…¬å…±"],
           
           "å¹¿ä¸œå½±è§†": ["å¹¿ä¸œå½±è§†-1","æµ‹è¯•é¢‘é“22"],
           "å¹¿ä¸œå°‘å„¿": ["å¹¿ä¸œå°‘å„¿"],
           "å¹¿ä¸œæ°‘ç”Ÿ": ["å¹¿å·å°"],
           "å¹¿ä¸œæ–°é—»": ["å¹¿å·å°"],
           "å¹¿ä¸œç»æµç§‘æ•™": ["å¹¿ä¸œç§‘æŠ€"],
           "å¹¿ä¸œä½“è‚²": ["å¹¿ä¸œä½“è‚²++","æµ‹è¯•é¢‘é“09"],
           "å¹¿ä¸œç æ±Ÿ": ["ç æ±Ÿå°","ç æ±Ÿå°BM","ç æ±Ÿé¢‘é“","ç æ±Ÿå°++","æµ‹è¯•é¢‘é“16",],
           "å¹¿ä¸œå²­å—æˆæ›²": ["å²­å—æˆå‰§"],
           
           "å¹¿è¥¿æ–°é—»": ["å¹¿è¥¿æ–°é—» é«˜æ¸…"],
           "å¹¿è¥¿å½±è§†": ["å¹¿è¥¿å½±è§† é«˜æ¸…"],
           "å¹¿è¥¿éƒ½å¸‚": ["å¹¿è¥¿éƒ½å¸‚ é«˜æ¸…"],
           "å¹¿è¥¿ç»¼è‰º": ["å¹¿è¥¿ç»¼è‰ºé«˜æ¸…"],
           "ç‰æ—æ–°é—»ç»¼åˆ": ["ç‰æ—æ–°é—» é«˜æ¸…"],
           "å—å®æ–°é—»ç»¼åˆ": ["å—å®æ–°é—» é«˜æ¸…"],
           "å—å®å…¬å…±": ["å—å®å…¬å…± é«˜æ¸…"],
           "å—å®å½±è§†å¨±ä¹": ["å—å®å½±è§† é«˜æ¸…","å—å®å½±è§†"],
           "å›¾æ–‡ä¿¡æ¯": ["ç‰æ—ä¿¡æ¯"],
           "å…´ä¸šç»¼åˆ": ["å…´ä¸šå°"],
           
           "æ²³åŒ—å½±è§†å‰§": ["æ²³åŒ—å½±è§†"],
           "æ²³åŒ—ä¸‰å†œ": ["æ²³åŒ—å†œæ°‘"],
           
           "é™•è¥¿æ–°é—»èµ„è®¯": ["é™•è¥¿ä¸€å¥—"],
           "é™•è¥¿éƒ½å¸‚é’æ˜¥": ["é™•è¥¿äºŒå¥—"],
           
       }
       
       # å›¾æ ‡æ–‡ä»¶è·¯å¾„
       LOGO_FILE = "Hotel/logo.txt"
       
       
       # ===============================
       # å·¥å…·å‡½æ•°
       # ===============================
       
       def get_random_headers():
           """è·å–éšæœºUser-Agentçš„headers"""
           return {
               "User-Agent": random.choice(USER_AGENTS),
               "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
               "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8",
               "Accept-Encoding": "gzip, deflate, br",
               "Connection": "keep-alive",
               "Upgrade-Insecure-Requests": "1",
               "Cookie": FOFA_COOKIE
           }
       
       
       def get_isp(ip):
           """IPè¿è¥å•†åˆ¤æ–­"""
           telecom_pattern = r"^(1\.|14\.|27\.|36\.|39\.|42\.|49\.|58\.|60\.|101\.|106\.|110\.|111\.|112\.|113\.|114\.|115\.|116\.|117\.|118\.|119\.|120\.|121\.|122\.|123\.|124\.|125\.|126\.|171\.|175\.|182\.|183\.|202\.|203\.|210\.|211\.|218\.|219\.|220\.|221\.|222\.)"
           unicom_pattern = r"^(42\.1[0-9]{0,2}|43\.|58\.|59\.|60\.|61\.|110\.|111\.|112\.|113\.|114\.|115\.|116\.|117\.|118\.|119\.|120\.|121\.|122\.|123\.|124\.|125\.|126\.|171\.8[0-9]|171\.9[0-9]|171\.1[0-9]{2}|175\.|182\.|183\.|210\.|211\.|218\.|219\.|220\.|221\.|222\.)"
           mobile_pattern = r"^(36\.|37\.|38\.|39\.1[0-9]{0,2}|42\.2|42\.3|47\.|106\.|111\.|112\.|113\.|114\.|115\.|116\.|117\.|118\.|119\.|120\.|121\.|122\.|123\.|124\.|125\.|126\.|134\.|135\.|136\.|137\.|138\.|139\.|150\.|151\.|152\.|157\.|158\.|159\.|170\.|178\.|182\.|183\.|184\.|187\.|188\.|189\.)"
       
           if re.match(telecom_pattern, ip):
               return "ç”µä¿¡"
           elif re.match(unicom_pattern, ip):
               return "è”é€š"
           elif re.match(mobile_pattern, ip):
               return "ç§»åŠ¨"
           else:
               return "æœªçŸ¥"
       
       
       def get_ip_info(ip_port):
           """è·å–IPåœ°ç†ä¿¡æ¯"""
           try:
               ip = ip_port.split(":")[0]
       
               # ä½¿ç”¨IP-APIæŸ¥è¯¢
               try:
                   response = requests.get(f"http://ip-api.com/json/{ip}?lang=zh-CN", timeout=5)
                   if response.status_code == 200:
                       data = response.json()
                       if data.get("status") == "success":
                           province = data.get("regionName", "æœªçŸ¥")
                           isp = get_isp(ip)
                           return province, isp, ip_port
               except:
                   pass
       
               return "æœªçŸ¥", "æœªçŸ¥", ip_port
       
           except Exception as e:
               return "æœªçŸ¥", "æœªçŸ¥", ip_port
       
       
       def parse_ip_line(line):
           """è§£æIPè¡Œï¼Œæ”¯æŒæ ¼å¼ï¼šip:port$è¿è¥å•†å·²å­˜æ´»nå¤©"""
           line = line.strip()
           if not line or line.startswith('#'):
               return None, None, 0, None, None
       
           # åŒ¹é…IP:ç«¯å£æ ¼å¼
           ip_match = re.match(r'(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d{1,5})', line)
           if not ip_match:
               return None, None, 0, None, None
       
           ip_port = ip_match.group(1)
       
           # å°è¯•è§£æå­˜æ´»å¤©æ•°
           days_match = re.search(r'å·²å­˜æ´»(\d+)å¤©', line)
           days = int(days_match.group(1)) if days_match else 0
       
           # å°è¯•è§£æè¿è¥å•†
           isp_match = re.search(r'\$([^$]+?)å·²å­˜æ´»', line)
           isp = isp_match.group(1).strip() if isp_match else ""
       
           # å°è¯•è§£ææœ€åæ›´æ–°æ—¥æœŸ
           date_match = re.search(r'æœ€åæ›´æ–°:(\d{4}-\d{2}-\d{2})', line)
           last_update = date_match.group(1) if date_match else None
       
           # å°è¯•è§£æé€Ÿåº¦
           speed_match = re.search(r'#é€Ÿåº¦:([\d.]+)MB/s', line)
           speed = float(speed_match.group(1)) if speed_match else 0.0
       
           return ip_port, isp, days, last_update, speed
       
       
       def parse_external_ip_line(line):
           """è§£æå¤–éƒ¨IPæ–‡ä»¶è¡Œï¼Œæ”¯æŒå¤šç§æ ¼å¼"""
           line = line.strip()
           if not line or line.startswith('#'):
               return None, None, 0
       
           # æ ¼å¼1: ip:port$è¿è¥å•† (å¦‚: 112.255.241.88:85$å®‰å¾½ç”µä¿¡)
           ip_isp_match = re.match(r'(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d{1,5})\$(.+)', line)
           if ip_isp_match:
               ip_port = ip_isp_match.group(1)
               isp = ip_isp_match.group(2).strip()
               return ip_port, isp, 0
       
           # æ ¼å¼2: åªæœ‰ip:port (å¦‚: 112.255.241.88:85)
           ip_only_match = re.match(r'(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d{1,5})', line)
           if ip_only_match:
               ip_port = ip_only_match.group(1)
               # å°è¯•æå–è¿è¥å•†ï¼ˆä»æ³¨é‡Šä¸­ï¼‰
               isp_match = re.search(r'#(.+)$', line)
               isp = isp_match.group(1).strip() if isp_match else ""
               return ip_port, isp, 0
       
           return None, None, 0
       
       
       def read_existing_ips(filepath):
           """è¯»å–ç°æœ‰æ–‡ä»¶å†…å®¹å¹¶è§£æ"""
           existing_ips = {}  # ip_port: (days, isp, last_update, speed)
           if os.path.exists(filepath):
               try:
                   with open(filepath, 'r', encoding='utf-8') as f:
                       for line in f:
                           ip_port, isp, days, last_update, speed = parse_ip_line(line)
                           if ip_port:
                               existing_ips[ip_port] = (days, isp, last_update, speed)
               except Exception as e:
                   print(f"âŒ è¯»å–æ–‡ä»¶ {filepath} å¤±è´¥: {e}")
       
           return existing_ips
       
       
       def encode_query(query):
           """ç¼–ç æŸ¥è¯¢å­—ç¬¦ä¸²ä¸ºbase64"""
           return base64.b64encode(query.encode()).decode()
       
       
       def generate_fofa_urls():
           """ç”ŸæˆFOFAæœç´¢URL"""
           urls = []
           pages = 1
           page_size = 50
       
           for query in SEARCH_QUERIES:
               encoded_query = encode_query(query)
               for page in range(1, pages + 1):
                   url = f"https://fofa.info/result?qbase64={encoded_query}&page={page}&page_size={page_size}"
                   urls.append(url)
       
           return urls
       
       
       # ===============================
       # ä¿®å¤çš„çˆ¬å–å‡½æ•°
       # ===============================
       
       def crawl_fofa_with_cookie_simple():
           """ç®€åŒ–ç‰ˆFOFAçˆ¬å–ï¼Œé¿å…é€’å½’é”™è¯¯"""
           urls = generate_fofa_urls()
           all_ips = set()
       
           print(f"ğŸ” å¼€å§‹çˆ¬å–FOFAï¼Œå…± {len(urls)} ä¸ªæœç´¢é¡µé¢")
       
           for i, url in enumerate(urls, 1):
               print(f"ğŸ“¡ æ­£åœ¨çˆ¬å–ç¬¬ {i}/{len(urls)} é¡µ: {url}")
       
               try:
                   time.sleep(random.uniform(3, 8))
       
                   headers = get_random_headers()
                   response = requests.get(url, headers=headers, timeout=15)
       
                   if response.status_code != 200:
                       print(f"âŒ ç¬¬ {i} é¡µè¯·æ±‚å¤±è´¥ï¼ŒçŠ¶æ€ç : {response.status_code}")
                       continue
       
                   # ä½¿ç”¨ç®€å•çš„IPåŒ¹é…æ¨¡å¼
                   page_ips = set()
       
                   # æ–¹æ³•1: ç›´æ¥æœç´¢IP:ç«¯å£æ ¼å¼
                   ip_matches = re.findall(r'\b(?:\d{1,3}\.){3}\d{1,3}:\d{1,5}\b', response.text)
                   for match in ip_matches:
                       ip_match = re.match(r'(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d{1,5})', match)
                       if ip_match:
                           ip_parts = ip_match.group(1).split('.')
                           if all(0 <= int(part) <= 255 for part in ip_parts):
                               port = int(ip_match.group(2))
                               if 1 <= port <= 65535:
                                   page_ips.add(match)
       
                   # æ–¹æ³•2: æœç´¢hrefä¸­çš„IP
                   href_matches = re.findall(r'href="[^"]*?//(\d+\.\d+\.\d+\.\d+:\d+)', response.text)
                   for match in href_matches:
                       ip_match = re.match(r'(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d{1,5})', match)
                       if ip_match:
                           ip_parts = ip_match.group(1).split('.')
                           if all(0 <= int(part) <= 255 for part in ip_parts):
                               port = int(ip_match.group(2))
                               if 1 <= port <= 65535:
                                   page_ips.add(match)
       
                   all_ips.update(page_ips)
                   print(f"âœ… ç¬¬ {i} é¡µè·å–åˆ° {len(page_ips)} ä¸ªIPï¼Œå½“å‰æ€»æ•° {len(all_ips)}")
       
               except Exception as e:
                   print(f"âŒ ç¬¬ {i} é¡µçˆ¬å–å¤±è´¥: {str(e)[:100]}")
       
           print(f"ğŸ¯ FOFAçˆ¬å–å®Œæˆï¼Œæ€»å…±è·å–åˆ° {len(all_ips)} ä¸ªæœ‰æ•ˆIP")
           return list(all_ips)
       
       
       # ===============================
       # ä¿®å¤çš„TXTæ–‡ä»¶è§£æå’ŒURLå¤„ç†
       # ===============================
       
       def fix_encoding(text):
           """ä¿®å¤ç¼–ç é—®é¢˜"""
           try:
               # å°è¯•UTF-8è§£ç 
               return text.encode('latin-1').decode('utf-8')
           except:
               try:
                   # å°è¯•GBKè§£ç 
                   return text.encode('latin-1').decode('gbk')
               except:
                   # å¦‚æœéƒ½å¤±è´¥ï¼Œè¿”å›åŸå§‹æ–‡æœ¬
                   return text
       
       
       def parse_txt_format(txt_content, ip_port):
           """è§£æTXTæ ¼å¼çš„é¢‘é“æ•°æ®ï¼Œæ­£ç¡®æ›¿æ¢å†…ç½‘åœ°å€ä¸ºå…¬ç½‘IP"""
           channels = []
           lines = txt_content.strip().split('\n')
       
           # æå–IPå’Œç«¯å£
           try:
               ip = ip_port.split(':')[0]
               port = ip_port.split(':')[1]
       
               # éªŒè¯IPå’Œç«¯å£æ ¼å¼
               if not re.match(r'^\d+\.\d+\.\d+\.\d+$', ip):
                   print(f"âŒ æ— æ•ˆçš„IPæ ¼å¼: {ip}")
                   return []
               if not port.isdigit() or not (1 <= int(port) <= 65535):
                   print(f"âŒ æ— æ•ˆçš„ç«¯å£: {port}")
                   return []
           except Exception as e:
               print(f"âŒ è§£æIPç«¯å£å¤±è´¥: {ip_port}, é”™è¯¯: {e}")
               return []
       
           for line in lines:
               line = line.strip()
               if not line or ',' not in line:
                   continue
       
               try:
                   # ä¿®å¤ç¼–ç é—®é¢˜
                   original_line = line
                   line = fix_encoding(line)
       
                   # åˆ†å‰²é¢‘é“åç§°å’ŒURL
                   parts = line.split(',', 1)
                   if len(parts) == 2:
                       name = parts[0].strip()
                       original_url = parts[1].strip()
       
                       # å¤„ç†URLè·¯å¾„
                       if original_url:
                           full_url = process_url(original_url, ip, port)
       
                           if full_url and validate_url_format(full_url, ip_port):
                               # åˆ›å»ºé¢‘é“æ•°æ®
                               channel_data = {
                                   "name": name,
                                   "url": full_url
                               }
                               channels.append(channel_data)
                               print(f"âœ… è§£æé¢‘é“: {name} -> {full_url}")
                           else:
                               print(f"âš ï¸ è·³è¿‡æ— æ•ˆURL: {name} -> {original_url}")
       
               except Exception as e:
                   print(f"âŒ è§£æTXTè¡Œå¤±è´¥: {original_line}, é”™è¯¯: {e}")
                   continue
       
           return channels
       
       
       def process_url(original_url, ip, port):
           """å¤„ç†URLï¼Œæ­£ç¡®æ›¿æ¢å†…ç½‘åœ°å€"""
           try:
               # å¦‚æœæ˜¯å†…ç½‘åœ°å€ (10.x.x.x, 172.16-31.x.x, 192.168.x.x)
               if re.match(r'http://(10\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|192\.168\.)', original_url):
                   # æå–è·¯å¾„éƒ¨åˆ†
                   path_match = re.match(r'http://[^/]+(/.+)', original_url)
                   if path_match:
                       # æ­£ç¡®æ„å»ºURL: http://å…¬ç½‘IP:ç«¯å£/è·¯å¾„
                       return f"http://{ip}:{port}{path_match.group(1)}"
                   else:
                       # å¦‚æœæ— æ³•æå–è·¯å¾„ï¼Œè¿”å›None
                       return None
               elif not original_url.startswith("http"):
                   # ç›¸å¯¹è·¯å¾„
                   if original_url.startswith("/"):
                       return f"http://{ip}:{port}{original_url}"
                   else:
                       return f"http://{ip}:{port}/{original_url}"
               else:
                   # å·²ç»æ˜¯å…¬ç½‘åœ°å€ï¼Œç›´æ¥ä½¿ç”¨
                   return original_url
           except Exception as e:
               print(f"âŒ å¤„ç†URLå¤±è´¥: {original_url}, é”™è¯¯: {e}")
               return None
       
       
       def validate_url_format(url, ip_port):
           """éªŒè¯URLæ ¼å¼æ˜¯å¦æ­£ç¡®"""
           try:
               # æ£€æŸ¥URLæ˜¯å¦ä¸ºç©º
               if not url:
                   return False
       
               # æ£€æŸ¥URLæ ¼å¼: å¿…é¡»åŒ…å«æ­£ç¡®çš„IP:ç«¯å£æ ¼å¼
               if not re.match(r'^http://\d+\.\d+\.\d+\.\d+:\d+/', url):
                   print(f"âš ï¸ URLæ ¼å¼ä¸æ­£ç¡®: {url}")
                   return False
       
               # æ£€æŸ¥æ˜¯å¦åŒ…å«é‡å¤çš„åè®®æˆ–IP
               if url.count("http://") > 1:
                   print(f"âš ï¸ URLåŒ…å«é‡å¤åè®®: {url}")
                   return False
       
               # æ£€æŸ¥æ˜¯å¦åŒ…å«é”™è¯¯çš„IPç«¯å£æ ¼å¼
               if "http://:" in url or "//:" in url:
                   print(f"âš ï¸ URLåŒ…å«ç©ºIPç«¯å£: {url}")
                   return False
       
               return True
           except Exception as e:
               print(f"âŒ éªŒè¯URLæ ¼å¼å¤±è´¥: {url}, é”™è¯¯: {e}")
               return False
       
       
       def test_ip_availability(ip_port):
           """æµ‹è¯•IPå¯ç”¨æ€§ï¼Œæ”¯æŒJSONå’ŒTXTä¸¤ç§æ ¼å¼"""
           try:
               # å…ˆéªŒè¯IPç«¯å£æ ¼å¼
               if not re.match(r'^\d+\.\d+\.\d+\.\d+:\d+$', ip_port):
                   print(f"âŒ æ— æ•ˆçš„IPç«¯å£æ ¼å¼: {ip_port}")
                   return False, None
       
               # å…ˆå°è¯•JSONæ ¼å¼æ¥å£
               json_url = f"http://{ip_port}/iptv/live/1000.json?key=txiptv"
               try:
                   response = requests.get(json_url, timeout=5)
                   if response.status_code == 200:
                       data = response.json()
                       if data.get("code") == 0 and "data" in data:
                           # å¤„ç†JSONæ•°æ®ä¸­çš„URL
                           for channel in data.get("data", []):
                               url = channel.get("url", "")
                               if url and not url.startswith("http"):
                                   if url.startswith("/"):
                                       channel["url"] = f"http://{ip_port}{url}"
                                   else:
                                       channel["url"] = f"http://{ip_port}/{url}"
                           print(f"âœ… {ip_port} JSONæ¥å£å¯ç”¨ï¼Œæ‰¾åˆ°{len(data.get('data', []))}ä¸ªé¢‘é“")
                           return True, data
               except Exception as e:
                   print(f"âŒ {ip_port} JSONæ¥å£å¤±è´¥: {e}")
       
               # å¦‚æœJSONæ¥å£å¤±è´¥ï¼Œå°è¯•TXTæ ¼å¼æ¥å£
               txt_url = f"http://{ip_port}/ZHGXTV/Public/json/live_interface.txt"
               try:
                   response = requests.get(txt_url, timeout=5)
                   if response.status_code == 200:
                       # è§£æTXTæ ¼å¼æ•°æ®
                       txt_data = parse_txt_format(response.text, ip_port)
                       if txt_data:
                           # è½¬æ¢ä¸ºä¸JSONç›¸åŒçš„ç»“æ„
                           data = {
                               "code": 0,
                               "data": txt_data
                           }
                           print(f"âœ… {ip_port} TXTæ¥å£å¯ç”¨ï¼Œæ‰¾åˆ°{len(txt_data)}ä¸ªé¢‘é“")
                           return True, data
                       else:
                           print(f"âŒ {ip_port} TXTè§£æåæ— æœ‰æ•ˆé¢‘é“")
                   else:
                       print(f"âŒ {ip_port} TXTæ¥å£HTTPçŠ¶æ€ç : {response.status_code}")
               except Exception as e:
                   print(f"âŒ {ip_port} TXTæ¥å£å¤±è´¥: {e}")
       
               print(f"âŒ {ip_port} æ‰€æœ‰æ¥å£å‡ä¸å¯ç”¨")
               return False, None
           except Exception as e:
               print(f"âŒ {ip_port} è¯·æ±‚å¤±è´¥: {e}")
               return False, None
       
       
       def get_province_tv_url(ip_port, json_data, province_name):
           """è·å–çœä»½å«è§†URL - ä½¿ç”¨CHANNEL_MAPPINGè¿›è¡ŒCCTV1åŒ¹é…"""
           try:
               # ä¼˜å…ˆæŸ¥æ‰¾CCTV1çš„å„ç§å˜ä½“ï¼Œä»æ˜ å°„ä¸­è·å–
               cctv1_variants = CHANNEL_MAPPING.get("CCTV1", [])
               # æ·»åŠ ä¸»é¢‘é“å
               cctv1_variants.append("CCTV1")
               
               for channel in json_data.get("data", []):
                   channel_name = channel.get("name", "").strip()
                   url = channel.get("url", "").strip()
                   
                   # æ£€æŸ¥æ˜¯å¦æ˜¯CCTV1çš„å˜ä½“ï¼šç²¾ç¡®åŒ¹é…
                   if channel_name in cctv1_variants:
                       if url and validate_url_format(url, ip_port):
                           print(f"âœ… æ‰¾åˆ°CCTV1é¢‘é“: {channel_name} -> {url}")
                           return url
               
               # å¦‚æœæ²¡æœ‰æ‰¾åˆ°CCTV1ï¼Œåˆ™æŸ¥æ‰¾å¯¹åº”çœä»½å«è§†
               if province_name and province_name != "æœªçŸ¥":
                   # ä»çœä»½æ˜ å°„è·å–å«è§†åç§°
                   tv_name = PROVINCE_TV_MAP.get(province_name, f"{province_name}å«è§†")
                   
                   for channel in json_data.get("data", []):
                       channel_name = channel.get("name", "").strip()
                       url = channel.get("url", "").strip()
                       
                       # ä½¿ç”¨åŒ…å«åŒ¹é…ï¼Œå› ä¸ºé¢‘é“åå¯èƒ½åŒ…å«å«è§†å
                       if tv_name in channel_name:
                           if url and validate_url_format(url, ip_port):
                               print(f"âœ… æ‰¾åˆ°{province_name}å«è§†: {channel_name} -> {url}")
                               return url
               
               # å¦‚æœæ—¢æ²¡æœ‰CCTV1ä¹Ÿæ²¡æœ‰å¯¹åº”å«è§†ï¼Œå°è¯•æŸ¥æ‰¾ä»»æ„å«è§†é¢‘é“
               for channel in json_data.get("data", []):
                   channel_name = channel.get("name", "").strip()
                   url = channel.get("url", "").strip()
                   
                   if "å«è§†" in channel_name:
                       if url and validate_url_format(url, ip_port):
                           print(f"âœ… æ‰¾åˆ°ä»»æ„å«è§†: {channel_name} -> {url}")
                           return url
               
               # æœ€åå°è¯•æŸ¥æ‰¾CCTVä»»æ„é¢‘é“
               for channel in json_data.get("data", []):
                   channel_name = channel.get("name", "").strip()
                   url = channel.get("url", "").strip()
                   
                   if "CCTV" in channel_name.upper():
                       if url and validate_url_format(url, ip_port):
                           print(f"âœ… æ‰¾åˆ°CCTVé¢‘é“: {channel_name} -> {url}")
                           return url
               
               print(f"âŒ åœ¨{ip_port}ä¸­æœªæ‰¾åˆ°åˆé€‚çš„æµ‹è¯•é¢‘é“")
               return None
               
           except Exception as e:
               print(f"âŒ è·å–æµ‹è¯•é¢‘é“URLå¤±è´¥: {e}")
               return None
       
       # categorize_channel å‡½æ•°ä¿æŒä¸å˜ï¼Œä½†ä¼šæ­£ç¡®å¤„ç†æ˜ å°„åçš„é¢‘é“å
       
       # ===============================
       # IPå¯ç”¨æ€§éªŒè¯å’Œæµ‹é€Ÿå‡½æ•°
       # ===============================
       
       def test_channel_speed(channel_url, max_attempts=2):
           """æµ‹è¯•é¢‘é“é€Ÿåº¦ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ï¼‰"""
           best_speed = 0.0
       
           for attempt in range(max_attempts):
               try:
                   # è·å–m3u8æ–‡ä»¶å†…å®¹
                   response = requests.get(channel_url, timeout=3)
                   if response.status_code != 200:
                       if attempt < max_attempts - 1:
                           print(f"ç¬¬{attempt + 1}æ¬¡æµ‹é€Ÿ {channel_url}: HTTP {response.status_code}ï¼Œå°†é‡è¯•")
                       continue
       
                   lines = response.text.strip().split('\n')
                   ts_lists = [line.split('/')[-1] for line in lines if line.startswith('#') == False and line.strip()]
                   if not ts_lists:
                       if attempt < max_attempts - 1:
                           print(f"ç¬¬{attempt + 1}æ¬¡æµ‹é€Ÿ {channel_url}: æ²¡æœ‰æ‰¾åˆ°TSåˆ—è¡¨ï¼Œå°†é‡è¯•")
                       continue
       
                   # è·å–TSæ–‡ä»¶çš„URL
                   channel_url_t = channel_url.rstrip(channel_url.split('/')[-1])
                   ts_url = channel_url_t + ts_lists[0]
       
                   # æµ‹é€Ÿé€»è¾‘
                   start_time = time.time()
                   try:
                       with eventlet.Timeout(5, False):
                           ts_response = requests.get(ts_url, timeout=6, stream=True)
                           if ts_response.status_code != 200:
                               if attempt < max_attempts - 1:
                                   print(f"ç¬¬{attempt + 1}æ¬¡æµ‹é€Ÿ {channel_url}: TSæ–‡ä»¶HTTP {ts_response.status_code}ï¼Œå°†é‡è¯•")
                               continue
       
                           # è¯»å–éƒ¨åˆ†å†…å®¹è¿›è¡Œæµ‹é€Ÿ
                           content_length = 0
                           chunk_size = 1024 * 1024  # 1MB
                           for chunk in ts_response.iter_content(chunk_size=chunk_size):
                               if chunk:
                                   content_length += len(chunk)
                                   # åªè¯»å–1MBç”¨äºæµ‹é€Ÿ
                                   if content_length >= chunk_size:
                                       break
       
                           resp_time = time.time() - start_time
       
                           if content_length > 0 and resp_time > 0:
                               normalized_speed = content_length / resp_time / 1024 / 1024
       
                               # æ›´æ–°æœ€ä½³é€Ÿåº¦
                               if normalized_speed > best_speed:
                                   best_speed = normalized_speed
       
                               # å¦‚æœé€Ÿåº¦åˆæ ¼ï¼Œä¸å†é‡è¯•
                               if normalized_speed > SPEED_THRESHOLD:
                                   break
                               else:
                                   if attempt < max_attempts - 1:
                                       print(f"ç¬¬{attempt + 1}æ¬¡æµ‹é€Ÿ {channel_url}: {normalized_speed:.3f} MB/sï¼Œå°†é‡è¯•")
                           else:
                               if attempt < max_attempts - 1:
                                   print(f"ç¬¬{attempt + 1}æ¬¡æµ‹é€Ÿ {channel_url}: è·å–å†…å®¹å¤±è´¥ï¼Œå°†é‡è¯•")
                   except eventlet.Timeout:
                       if attempt < max_attempts - 1:
                           print(f"ç¬¬{attempt + 1}æ¬¡æµ‹é€Ÿ {channel_url}: è¯·æ±‚è¶…æ—¶ï¼Œå°†é‡è¯•")
                       continue
                   except Exception as e:
                       if attempt < max_attempts - 1:
                           print(f"ç¬¬{attempt + 1}æ¬¡æµ‹é€Ÿ {channel_url} å¤±è´¥: {str(e)}ï¼Œå°†é‡è¯•")
                       continue
       
               except Exception as e:
                   if attempt < max_attempts - 1:
                       print(f"ç¬¬{attempt + 1}æ¬¡æµ‹é€Ÿ {channel_url} å¤„ç†å¤±è´¥: {str(e)}ï¼Œå°†é‡è¯•")
                   continue
       
           return best_speed
       
       
       def test_single_ip(ip_port, province_name):
           """æµ‹è¯•å•ä¸ªIPçš„å¯ç”¨æ€§å’Œé€Ÿåº¦"""
           try:
               # 1. æµ‹è¯•IPå¯ç”¨æ€§
               is_available, json_data = test_ip_availability(ip_port)
               if not is_available:
                   return 0.0, False, None
       
               # 2. è·å–æµ‹è¯•é¢‘é“URLï¼ˆä¼˜å…ˆCCTV1ï¼Œå…¶æ¬¡çœä»½å«è§†ï¼‰
               channel_url = get_province_tv_url(ip_port, json_data, province_name)
               if not channel_url:
                   return 0.0, False, json_data
       
               print(f"ğŸ” æµ‹è¯•é¢‘é“URL: {channel_url}")
       
               # 3. æµ‹é€Ÿ
               speed = test_channel_speed(channel_url)
               return speed, speed > SPEED_THRESHOLD, json_data
       
           except Exception as e:
               print(f"âŒ æµ‹è¯•IP {ip_port} å¤±è´¥: {e}")
               return 0.0, False, None
       
       
       def speed_test_ips(ip_list, province_name):
           """å¤šçº¿ç¨‹æµ‹é€ŸIPåˆ—è¡¨ï¼ˆä¿®å¤è¿”å›å€¼è§£åŒ…é”™è¯¯ï¼‰"""
           results = []
           checked = [0]
           total_count = len(ip_list)
       
           def show_progress():
               """æ˜¾ç¤ºè¿›åº¦"""
               while checked[0] < total_count:
                   numberx = checked[0] / total_count * 100
                   print(f"å·²æµ‹è¯•{checked[0]}/{total_count}ï¼Œå¯ç”¨é¢‘é“:{len(results)}ä¸ªï¼Œè¿›åº¦:{numberx:.2f}%")
                   time.sleep(5)
       
           def worker():
               """å·¥ä½œçº¿ç¨‹ - ä¿®å¤è¿”å›å€¼è§£åŒ…é”™è¯¯"""
               while True:
                   try:
                       # ä»é˜Ÿåˆ—ä¸­è·å–ä»»åŠ¡
                       with task_queue_lock:
                           if not task_queue:
                               break
                           ip_info = task_queue.pop(0)
       
                       ip_port = ip_info[0]
                       # ä¿®å¤ï¼šæ­£ç¡®æ¥æ”¶ä¸‰ä¸ªè¿”å›å€¼
                       speed, is_usable, json_data = test_single_ip(ip_port, province_name)
       
                       if is_usable:
                           result = (ip_info[0], ip_info[1], ip_info[2], speed)
                           results.append(result)
                           print(f"âœ“ {ip_port}: {speed:.3f} MB/s")
                       else:
                           print(f"Ã— {ip_port}: {speed:.3f} MB/s")
       
                       checked[0] += 1
                   except Exception as e:
                       checked[0] += 1
                       print(f"å¤„ç† {ip_info[0]} æ—¶å‘ç”Ÿé”™è¯¯: {e}")
       
           # åˆ›å»ºä»»åŠ¡é˜Ÿåˆ—
           task_queue = ip_list.copy()
           task_queue_lock = threading.Lock()
       
           # å¯åŠ¨è¿›åº¦æ˜¾ç¤ºçº¿ç¨‹
           progress_thread = threading.Thread(target=show_progress, daemon=True)
           progress_thread.start()
       
           # åˆ›å»ºå·¥ä½œçº¿ç¨‹
           threads = []
           for _ in range(min(10, len(ip_list))):
               thread = threading.Thread(target=worker)
               thread.daemon = True
               thread.start()
               threads.append(thread)
       
           # ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
           for thread in threads:
               thread.join()
       
           # æŒ‰é€Ÿåº¦æ’åº
           results.sort(key=lambda x: x[3], reverse=True)
           return results
       
       
       # ===============================
       # æ–‡ä»¶ç®¡ç†å’Œæ›´æ–°å‡½æ•°
       # ===============================
       
       def calculate_days_between(date_str1, date_str2):
           """è®¡ç®—ä¸¤ä¸ªæ—¥æœŸå­—ç¬¦ä¸²ä¹‹é—´çš„å¤©æ•°å·®"""
           try:
               date1 = datetime.strptime(date_str1, "%Y-%m-%d")
               date2 = datetime.strptime(date_str2, "%Y-%m-%d")
               return (date2 - date1).days
           except:
               return 0
       
       
       def update_ip_file(filepath, new_usable_ips):
           """æ›´æ–°IPæ–‡ä»¶ - ä¿®å¤å­˜æ´»å¤©æ•°è®¡ç®—"""
           try:
               existing_ips = read_existing_ips(filepath)
               current_date = datetime.now().strftime("%Y-%m-%d")
       
               updated_ips = {}
               for ip_port, (days, isp, last_update, old_speed) in existing_ips.items():
                   is_still_usable = any(ip[0] == ip_port for ip in new_usable_ips)
       
                   if is_still_usable:
                       if not isp:
                           ip = ip_port.split(":")[0]
                           isp = get_isp(ip)
       
                       if last_update:
                           days_diff = calculate_days_between(last_update, current_date)
                           if days_diff > 0:
                               new_days = days + days_diff
                           else:
                               new_days = days
                       else:
                           new_days = 1
       
                       # è·å–æ–°çš„é€Ÿåº¦
                       new_speed = old_speed
                       for ip_info in new_usable_ips:
                           if ip_info[0] == ip_port:
                               new_speed = ip_info[3]
                               break
       
                       updated_ips[ip_port] = (new_days, isp, current_date, new_speed)
                   # åˆ é™¤ä¸å†å¯ç”¨çš„IPï¼ˆåŒ…æ‹¬æ²¡æœ‰JSONæ•°æ®å’Œé€Ÿåº¦ä½äºé˜ˆå€¼çš„ï¼‰
                   # ä¸å†æ·»åŠ åˆ°updated_ipsä¸­ï¼Œç›¸å½“äºåˆ é™¤
       
               for ip_info in new_usable_ips:
                   ip_port, isp, old_days, speed = ip_info
                   if ip_port not in updated_ips:
                       if not isp:
                           ip = ip_port.split(":")[0]
                           isp = get_isp(ip)
                       updated_ips[ip_port] = (1, isp, current_date, speed)
       
               if not updated_ips:
                   if os.path.exists(filepath):
                       os.remove(filepath)
                   print(f"ğŸ—‘ï¸ åˆ é™¤ç©ºæ–‡ä»¶: {os.path.basename(filepath)}")
                   return
       
               with open(filepath, 'w', encoding='utf-8') as f:
                   f.write(f"# æ›´æ–°æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                   f.write(f"# æµ‹é€Ÿé˜ˆå€¼: {SPEED_THRESHOLD} MB/s\n")
                   f.write("# æ ¼å¼: IP:ç«¯å£$è¿è¥å•†å·²å­˜æ´»nå¤©#æœ€åæ›´æ–°:YYYY-MM-DD#é€Ÿåº¦\n")
                   f.write("=" * 50 + "\n")
       
                   sorted_ips = sorted(updated_ips.items(), key=lambda x: x[1][0], reverse=True)
       
                   for ip_port, (days, isp, last_update, speed) in sorted_ips:
                       speed_info = f"#é€Ÿåº¦:{speed:.3f}MB/s" if speed > 0 else ""
                       f.write(f"{ip_port}${isp}å·²å­˜æ´»{days}å¤©#æœ€åæ›´æ–°:{last_update}{speed_info}\n")
       
               print(f"ğŸ’¾ å·²æ›´æ–° {os.path.basename(filepath)}ï¼Œæœ‰æ•ˆIP: {len(updated_ips)} ä¸ª")
       
           except Exception as e:
               print(f"âŒ æ›´æ–°æ–‡ä»¶ {filepath} å¤±è´¥: {e}")
       
       
       def validate_existing_ips():
           """éªŒè¯ç°æœ‰IPæ–‡ä»¶ä¸­çš„IPï¼Œåˆ é™¤æ²¡æœ‰JSONæ•°æ®å’Œé€Ÿåº¦ä½äºé˜ˆå€¼çš„IP"""
           print("ğŸ” å¼€å§‹éªŒè¯ç°æœ‰IPæ–‡ä»¶...")
       
           for filename in os.listdir(IP_DIR):
               if filename.endswith('.txt') and filename != "ip_summary.txt":
                   filepath = os.path.join(IP_DIR, filename)
       
                   match = re.match(r'(.+?)(ç”µä¿¡|è”é€š|ç§»åŠ¨|æœªçŸ¥)\.txt', filename)
                   if not match:
                       continue
       
                   province = match.group(1)
                   isp = match.group(2)
       
                   print(f"ğŸ“‹ éªŒè¯æ–‡ä»¶: {filename} (çœä»½: {province}, è¿è¥å•†: {isp})")
       
                   existing_ips = read_existing_ips(filepath)
                   if not existing_ips:
                       print(f"âš ï¸ æ–‡ä»¶ {filename} ä¸ºç©ºï¼Œè·³è¿‡éªŒè¯")
                       continue
       
                   # æµ‹è¯•æ¯ä¸ªIPçš„å¯ç”¨æ€§
                   ip_list = []
                   for ip_port, (days, isp_val, last_update, speed) in existing_ips.items():
                       ip_list.append((ip_port, isp_val, days))
       
                   if ip_list:
                       usable_ips = speed_test_ips(ip_list, province)
                       update_ip_file(filepath, usable_ips)
                   else:
                       print(f"âš ï¸ æ–‡ä»¶ {filename} ä¸­æ²¡æœ‰æœ‰æ•ˆçš„IPï¼Œåˆ é™¤æ–‡ä»¶")
                       if os.path.exists(filepath):
                           os.remove(filepath)
       
           print("âœ… ç°æœ‰IPéªŒè¯å®Œæˆ")
       
       
       def process_external_ip_file():
           """å¤„ç†å¤–éƒ¨IPæ–‡ä»¶ï¼Œåœ¨åŸæ–‡ä»¶ä¸Šç›´æ¥æ›´æ–°ï¼Œä¸ç”Ÿæˆå¤‡ä»½"""
           print("ğŸ” å¼€å§‹å¤„ç†å¤–éƒ¨IPæ–‡ä»¶...")
       
           external_files = ["ip.txt", "ips.txt", "iplist.txt"]  # æ”¯æŒçš„æ–‡ä»¶å
       
           for ext_file in external_files:
               ext_filepath = os.path.join(IP_DIR, ext_file)
       
               if os.path.exists(ext_filepath):
                   print(f"ğŸ“ å¤„ç†å¤–éƒ¨IPæ–‡ä»¶: {ext_file}")
       
                   # è®°å½•åŸå§‹IPæ•°é‡
                   original_ip_count = 0
       
                   with open(ext_filepath, 'r', encoding='utf-8') as f:
                       original_content = f.read()
                       lines = original_content.strip().split('\n')
       
                   # è§£ææ‰€æœ‰IP
                   ip_list = []
                   ip_geoinfo = {}  # å­˜å‚¨IPçš„åœ°ç†ä¿¡æ¯
       
                   for line_num, line in enumerate(lines, 1):
                       line = line.strip()
                       if not line or line.startswith('#'):
                           continue
       
                       # å°è¯•å¤šç§æ ¼å¼è§£æ
                       # 1. æ ‡å‡†æ ¼å¼
                       ip_port, isp, days, last_update, speed = parse_ip_line(line)
       
                       if not ip_port:
                           # 2. å¤–éƒ¨æ ¼å¼
                           ip_port, isp, days = parse_external_ip_line(line)
       
                       if ip_port:
                           # éªŒè¯IP:ç«¯å£æ ¼å¼
                           ip_match = re.match(r'(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d{1,5})', ip_port)
                           if ip_match:
                               ip_parts = ip_match.group(1).split('.')
                               if all(0 <= int(part) <= 255 for part in ip_parts):
                                   port = int(ip_match.group(2))
                                   if 1 <= port <= 65535:
                                       # è·å–IPçš„åœ°ç†ä¿¡æ¯
                                       province, isp_detected, _ = get_ip_info(ip_port)
       
                                       # ä¼˜å…ˆä½¿ç”¨è§£æåˆ°çš„è¿è¥å•†ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨æ£€æµ‹çš„
                                       if not isp or isp == "":
                                           isp = isp_detected
       
                                       ip_list.append((ip_port, isp, 0))
                                       ip_geoinfo[ip_port] = province
                                       original_ip_count += 1
                                       print(
                                           f"âœ… ç¬¬{line_num}è¡Œ: è§£æåˆ°IP {ip_port} (çœä»½: {province}, è¿è¥å•†: {isp if isp else 'è‡ªåŠ¨æ£€æµ‹'})")
                                   else:
                                       print(f"âš ï¸ ç¬¬{line_num}è¡Œ: ç«¯å£ {port} æ— æ•ˆï¼Œè·³è¿‡")
                               else:
                                   print(f"âš ï¸ ç¬¬{line_num}è¡Œ: IPåœ°å€ {ip_match.group(1)} æ— æ•ˆï¼Œè·³è¿‡")
                           else:
                               print(f"âš ï¸ ç¬¬{line_num}è¡Œ: æ ¼å¼æ— æ•ˆï¼Œè·³è¿‡")
                       else:
                           print(f"âš ï¸ ç¬¬{line_num}è¡Œ: æ— æ³•è§£æï¼Œè·³è¿‡")
       
                   if not ip_list:
                       print(f"âš ï¸ æ–‡ä»¶ {ext_file} ä¸­æ²¡æœ‰è§£æåˆ°æœ‰æ•ˆçš„IP")
                       continue
       
                   print(f"ğŸ“Š ä» {ext_file} ä¸­å…±è§£æåˆ° {len(ip_list)} ä¸ªIPï¼Œå¼€å§‹æµ‹è¯•...")
       
                   # æµ‹è¯•IP
                   usable_ips = []
       
                   # åˆ›å»ºä»»åŠ¡é˜Ÿåˆ—
                   task_queue = ip_list.copy()
                   task_queue_lock = threading.Lock()
                   results = []
                   checked = [0]
                   total_count = len(ip_list)
       
                   def show_progress():
                       """æ˜¾ç¤ºè¿›åº¦"""
                       while checked[0] < total_count:
                           numberx = checked[0] / total_count * 100
                           print(f"å·²æµ‹è¯•{checked[0]}/{total_count}ï¼Œå¯ç”¨IP:{len(results)}ä¸ªï¼Œè¿›åº¦:{numberx:.2f}%")
                           time.sleep(2)
       
                   def worker():
                       """å·¥ä½œçº¿ç¨‹"""
                       while True:
                           try:
                               # ä»é˜Ÿåˆ—ä¸­è·å–ä»»åŠ¡
                               with task_queue_lock:
                                   if not task_queue:
                                       break
                                   ip_info = task_queue.pop(0)
       
                               ip_port = ip_info[0]
                               province = ip_geoinfo.get(ip_port, "æœªçŸ¥")
       
                               # æµ‹è¯•IP
                               speed, is_usable, json_data = test_single_ip(ip_port, province)
       
                               if is_usable:
                                   result = (ip_port, ip_info[1], 0, speed)
                                   results.append(result)
                                   print(f"âœ“ {ip_port} ({province}): {speed:.3f} MB/s")
                               else:
                                   print(f"Ã— {ip_port} ({province}): {speed:.3f} MB/s")
       
                               checked[0] += 1
                           except Exception as e:
                               checked[0] += 1
                               print(f"å¤„ç† {ip_info[0]} æ—¶å‘ç”Ÿé”™è¯¯: {e}")
       
                   # å¯åŠ¨è¿›åº¦æ˜¾ç¤ºçº¿ç¨‹
                   progress_thread = threading.Thread(target=show_progress, daemon=True)
                   progress_thread.start()
       
                   # åˆ›å»ºå·¥ä½œçº¿ç¨‹
                   threads = []
                   thread_count = min(10, len(ip_list))
                   for _ in range(thread_count):
                       thread = threading.Thread(target=worker)
                       thread.daemon = True
                       thread.start()
                       threads.append(thread)
       
                   # ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
                   for thread in threads:
                       thread.join()
       
                   # ç­‰å¾…è¿›åº¦çº¿ç¨‹ç»“æŸ
                   time.sleep(1)
       
                   usable_ips = results
       
                   if not usable_ips:
                       print(f"âŒ æ–‡ä»¶ {ext_file} ä¸­æ²¡æœ‰å¯ç”¨çš„IPï¼Œåˆ é™¤æ–‡ä»¶")
                       os.remove(ext_filepath)
                       continue
       
                   # æ›´æ–°åŸæ–‡ä»¶ï¼Œä¸ç”Ÿæˆå¤‡ä»½
                   current_date = datetime.now().strftime("%Y-%m-%d")
                   with open(ext_filepath, 'w', encoding='utf-8') as f:
                       f.write(f"# æ›´æ–°æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                       f.write(f"# æµ‹é€Ÿé˜ˆå€¼: {SPEED_THRESHOLD} MB/s\n")
                       f.write("# æ ¼å¼: IP:ç«¯å£$è¿è¥å•†å·²å­˜æ´»nå¤©#æœ€åæ›´æ–°:YYYY-MM-DD#é€Ÿåº¦\n")
                       f.write("# è¯´æ˜: åŸå§‹IP: " + str(original_ip_count) + "ä¸ªï¼Œå¯ç”¨IP: " + str(len(usable_ips)) + "ä¸ª\n")
                       f.write("=" * 50 + "\n")
       
                       # æŒ‰é€Ÿåº¦æ’åº
                       usable_ips.sort(key=lambda x: x[3], reverse=True)
       
                       for ip_port, isp, days, speed in usable_ips:
                           if not isp or isp == "":
                               ip = ip_port.split(":")[0]
                               isp = get_isp(ip)
       
                           speed_info = f"#é€Ÿåº¦:{speed:.3f}MB/s" if speed > 0 else ""
                           f.write(f"{ip_port}${isp}å·²å­˜æ´»1å¤©#æœ€åæ›´æ–°:{current_date}{speed_info}\n")
       
                   print(f"ğŸ’¾ å·²æ›´æ–° {ext_file}ï¼ŒåŸå§‹IP: {original_ip_count}ä¸ªï¼Œå¯ç”¨IP: {len(usable_ips)}ä¸ª")
       
       
       def process_new_ips(new_ips):
           """å¤„ç†æ–°è·å–çš„IP"""
           if not new_ips:
               print("âš ï¸ æ²¡æœ‰è·å–åˆ°æ–°IP")
               return
       
           print(f"ğŸ”§ å¼€å§‹å¤„ç† {len(new_ips)} ä¸ªæ–°IP...")
       
           province_isp_dict = {}
           with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
               future_to_ip = {executor.submit(get_ip_info, ip[0]): ip for ip in new_ips}
       
               for future in concurrent.futures.as_completed(future_to_ip):
                   ip_info = future_to_ip[future]
                   ip_port, isp, days = ip_info
                   province, isp_detected, ip_port = future.result()
       
                   # ä¼˜å…ˆä½¿ç”¨è§£æåˆ°çš„è¿è¥å•†ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨æ£€æµ‹çš„
                   if not isp or isp == "":
                       isp = isp_detected
       
                   if not province or province == "æœªçŸ¥":
                       province = "å…¶ä»–"
                   else:
                       province = province.replace("çœ", "").replace("å¸‚", "").replace("è‡ªæ²»åŒº", "").replace("ç‰¹åˆ«è¡Œæ”¿åŒº", "").strip()
                       if not province:
                           province = "å…¶ä»–"
       
                   if not isp or isp == "æœªçŸ¥":
                       ip = ip_port.split(":")[0]
                       isp = get_isp(ip)
       
                   fname = f"{province}{isp}.txt"
                   province_isp_dict.setdefault(fname, []).append((ip_port, isp, 0))
       
           for fname, ip_list in province_isp_dict.items():
               filepath = os.path.join(IP_DIR, fname)
       
               match = re.match(r'(.+?)(ç”µä¿¡|è”é€š|ç§»åŠ¨|æœªçŸ¥)\.txt', fname)
               province = match.group(1) if match else "å…¶ä»–"
       
               print(f"ğŸ§ª æµ‹è¯• {fname} ä¸­çš„ {len(ip_list)} ä¸ªæ–°IP...")
               usable_ips = speed_test_ips(ip_list, province)
       
               if usable_ips:
                   update_ip_file(filepath, usable_ips)
               else:
                   print(f"âš ï¸ {fname} ä¸­æ²¡æœ‰å¯ç”¨çš„æ–°IP")
       
           print("âœ… æ–°IPå¤„ç†å®Œæˆ")
       
       
       # ===============================
       # ä¿®å¤çš„é¢‘é“æ–‡ä»¶ç”ŸæˆåŠŸèƒ½
       # ===============================
       
       
       def load_channel_logos():
           """åŠ è½½é¢‘é“å›¾æ ‡æ˜ å°„"""
           channel_logos = {}
           if os.path.exists(LOGO_FILE):
               try:
                   with open(LOGO_FILE, 'r', encoding='utf-8') as f:
                       for line in f:
                           line = line.strip()
                           if line and ',' in line:
                               parts = line.split(',', 1)
                               if len(parts) == 2:
                                   channel_name = parts[0].strip()
                                   logo_url = parts[1].strip()
                                   channel_logos[channel_name] = logo_url
                   print(f"âœ… å·²åŠ è½½ {len(channel_logos)} ä¸ªé¢‘é“å›¾æ ‡")
               except Exception as e:
                   print(f"âŒ åŠ è½½é¢‘é“å›¾æ ‡æ–‡ä»¶å¤±è´¥: {e}")
           else:
               print(f"âš ï¸ é¢‘é“å›¾æ ‡æ–‡ä»¶ä¸å­˜åœ¨: {LOGO_FILE}")
           return channel_logos
       
       
       def map_channel_name(raw_name):
           """å°†åŸå§‹é¢‘é“åç§°æ˜ å°„åˆ°æ ‡å‡†åç§° - ä½¿ç”¨ç²¾ç¡®åŒ¹é…"""
           if not raw_name:
               return "æœªçŸ¥é¢‘é“"
       
           clean_name = raw_name.strip()
       
           # éå†é¢‘é“æ˜ å°„ï¼Œè¿›è¡Œç²¾ç¡®åŒ¹é…
           for standard_name, variants in CHANNEL_MAPPING.items():
               # æ£€æŸ¥æ˜¯å¦æ˜¯ä¸»é¢‘é“å
               if clean_name == standard_name:
                   return standard_name
               # æ£€æŸ¥æ˜¯å¦æ˜¯åˆ«å
               for variant in variants:
                   if clean_name == variant:
                       return standard_name
       
           # å¦‚æœæœªæ‰¾åˆ°åŒ¹é…ï¼Œè¿”å›åŸå§‹åç§°
           return clean_name
       
       def categorize_channel(channel_name):
           """å°†é¢‘é“åˆ†ç±»"""
           for category, channels in CHANNEL_CATEGORIES.items():
               if channel_name in channels:
                   return category
           return "å…¶ä»–é¢‘é“"
       
       def get_channel_logo(channel_name, logo_dict):
           """è·å–é¢‘é“å›¾æ ‡URL - ä¿®æ”¹ä¸ºç›´æ¥åŒ¹é…"""
           # ç›´æ¥ä½¿ç”¨é¢‘é“åæŸ¥æ‰¾
           if channel_name in logo_dict:
               return logo_dict[channel_name]
       
           # å°è¯•ç²¾ç¡®åŒ¹é…
           for logo_channel, logo_url in logo_dict.items():
               if channel_name == logo_channel:
                   return logo_url
       
           return ""
       
       
       def collect_all_channels():
           """æ”¶é›†æ‰€æœ‰IPæ–‡ä»¶ä¸­çš„é¢‘é“ä¿¡æ¯"""
           all_channels = {}
           logo_dict = load_channel_logos()
       
           print("ğŸ“º å¼€å§‹æ”¶é›†æ‰€æœ‰é¢‘é“ä¿¡æ¯...")
       
           for filename in os.listdir(IP_DIR):
               if filename.endswith('.txt') and filename != "ip_summary.txt":
                   filepath = os.path.join(IP_DIR, filename)
       
                   existing_ips = read_existing_ips(filepath)
       
                   for ip_port, (days, isp, last_update, speed) in existing_ips.items():
                       if days > 0:
                           try:
                               is_available, json_data = test_ip_availability(ip_port)
                               if is_available and json_data:
                                   for channel in json_data.get("data", []):
                                       raw_name = channel.get("name", "")
                                       if raw_name:
                                           std_name = map_channel_name(raw_name)
                                           category = categorize_channel(std_name)
                                           logo = get_channel_logo(std_name, logo_dict)
       
                                           url = channel.get("url", "")
                                           if url and validate_url_format(url, ip_port):
                                               # ç¡®ä¿URLæ ¼å¼æ­£ç¡®
                                               play_url = url
       
                                               channel_key = f"{std_name}|{play_url}"
                                               if channel_key not in all_channels:
                                                   all_channels[channel_key] = {
                                                       "name": std_name,
                                                       "url": play_url,
                                                       "logo": logo,
                                                       "category": category,
                                                       "ip": ip_port,
                                                       "speed": speed
                                                   }
                                           else:
                                               print(f"âš ï¸ è·³è¿‡æ— æ•ˆURLçš„é¢‘é“: {std_name} -> {url}")
                           except Exception as e:
                               print(f"âŒ å¤„ç†IP {ip_port} çš„é¢‘é“ä¿¡æ¯å¤±è´¥: {e}")
       
           print(f"âœ… å…±æ”¶é›†åˆ° {len(all_channels)} ä¸ªæœ‰æ•ˆé¢‘é“")
           return all_channels
       
       
       def generate_iptv_txt(channels_dict):
           """ç”ŸæˆIPTV.txtæ–‡ä»¶ - ä¿®å¤ç¼–ç å’Œæ’åºé—®é¢˜"""
           output_file = os.path.join(CHANNEL_DIR, "IPTV.txt")
       
           # æŒ‰åˆ†ç±»ç»„ç»‡é¢‘é“
           categorized_channels = {}
           for channel_info in channels_dict.values():
               category = channel_info["category"]
               categorized_channels.setdefault(category, []).append(channel_info)
       
           # æŒ‰åˆ†ç±»é¡ºåºæ’åº
           sorted_categories = []
           for cat in CHANNEL_CATEGORIES.keys():
               if cat in categorized_channels:
                   sorted_categories.append(cat)
       
           try:
               with open(output_file, 'w', encoding='utf-8', errors='ignore') as f:
                   update_time = datetime.now().strftime('%Y/%m/%d %H:%M')
                   f.write(f"{update_time},#genre#\n\n")
       
                   for category in sorted_categories:
                       f.write(f"{category},#genre#\n")
                       channels = categorized_channels[category]
       
                       # å…ˆæŒ‰é¢‘é“åç§°åˆ†ç»„
                       channel_groups = {}
                       for channel in channels:
                           channel_name = channel["name"]
                           if channel_name not in channel_groups:
                               channel_groups[channel_name] = []
                           channel_groups[channel_name].append(channel)
       
                       # å¯¹æ¯ä¸ªé¢‘é“ç»„å†…çš„URLæŒ‰é€Ÿåº¦æ’åº
                       for channel_name, channel_list in channel_groups.items():
                           # æŒ‰é€Ÿåº¦é™åºæ’åº
                           channel_list.sort(key=lambda x: x["speed"], reverse=True)
       
                           for channel in channel_list:
                               f.write(f"{channel['name']},{channel['url']}\n")
       
                       f.write("\n")
       
               print(f"ğŸ’¾ å·²ç”ŸæˆIPTV.txtï¼Œå…± {len(channels_dict)} ä¸ªé¢‘é“ï¼Œ{len(sorted_categories)} ä¸ªåˆ†ç±»")
               return True
       
           except Exception as e:
               print(f"âŒ ç”ŸæˆIPTV.txtå¤±è´¥: {e}")
               return False
       
       
       def generate_iptv_m3u(channels_dict):
           """ç”ŸæˆIPTV.m3uæ–‡ä»¶ - ä¿®å¤æ’åºé—®é¢˜"""
           output_file = os.path.join(CHANNEL_DIR, "IPTV.m3u")
       
           categorized_channels = {}
           for channel_info in channels_dict.values():
               category = channel_info["category"]
               categorized_channels.setdefault(category, []).append(channel_info)
       
           sorted_categories = []
           for cat in CHANNEL_CATEGORIES.keys():
               if cat in categorized_channels:
                   sorted_categories.append(cat)
       
           try:
               with open(output_file, 'w', encoding='utf-8') as f:
                   f.write("#EXTM3U\n")
                   f.write('x-tvg-url=""\n')
       
                   for category in sorted_categories:
                       channels = categorized_channels[category]
       
                       # å…ˆæŒ‰é¢‘é“åç§°åˆ†ç»„
                       channel_groups = {}
                       for channel in channels:
                           channel_name = channel["name"]
                           if channel_name not in channel_groups:
                               channel_groups[channel_name] = []
                           channel_groups[channel_name].append(channel)
       
                       # å¯¹æ¯ä¸ªé¢‘é“ç»„å†…çš„URLæŒ‰é€Ÿåº¦æ’åº
                       for channel_name, channel_list in channel_groups.items():
                           # æŒ‰é€Ÿåº¦é™åºæ’åº
                           channel_list.sort(key=lambda x: x["speed"], reverse=True)
       
                           for channel in channel_list:
                               logo_info = f' tvg-logo="{channel["logo"]}"' if channel["logo"] else ""
                               f.write(
                                   f'#EXTINF:-1 tvg-name="{channel["name"]}"{logo_info} group-title="{category}",{channel["name"]}\n')
                               f.write(f'{channel["url"]}\n')
       
               print(f"ğŸ’¾ å·²ç”ŸæˆIPTV.m3uï¼Œå…± {len(channels_dict)} ä¸ªé¢‘é“ï¼Œ{len(sorted_categories)} ä¸ªåˆ†ç±»")
               return True
       
           except Exception as e:
               print(f"âŒ ç”ŸæˆIPTV.m3uå¤±è´¥: {e}")
               return False
       
       
       def generate_channel_files():
           """ç”Ÿæˆé¢‘é“æ–‡ä»¶ï¼ˆIPTV.txtå’ŒIPTV.m3uï¼‰"""
           print("ğŸ¬ å¼€å§‹ç”Ÿæˆé¢‘é“æ–‡ä»¶...")
       
           all_channels = collect_all_channels()
       
           if not all_channels:
               print("âŒ æ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„é¢‘é“")
               return False
       
           txt_success = generate_iptv_txt(all_channels)
           m3u_success = generate_iptv_m3u(all_channels)
       
           if txt_success and m3u_success:
               print("âœ… é¢‘é“æ–‡ä»¶ç”Ÿæˆå®Œæˆï¼")
               return True
           else:
               print("âŒ é¢‘é“æ–‡ä»¶ç”Ÿæˆå¤±è´¥")
               return False
       
       
       # ===============================
       # ä¸»å‡½æ•°
       # ===============================
       
       def main():
           """ä¸»å‡½æ•°"""
           print("=" * 60)
           print("ğŸŒ FOFA IPåœ°å€æŠ“å–ä¸éªŒè¯å·¥å…·")
           print(f"ğŸ“ IPç›®å½•: {IP_DIR}")
           print(f"ğŸ“º é¢‘é“ç›®å½•: {CHANNEL_DIR}")
           print(f"âš¡ æµ‹é€Ÿé˜ˆå€¼: {SPEED_THRESHOLD} MB/s")
           print("=" * 60)
       
           # 1. éªŒè¯ç°æœ‰IPæ–‡ä»¶
           validate_existing_ips()
       
           # 2. å¤„ç†å¤–éƒ¨IPæ–‡ä»¶
           process_external_ip_file()
       
           print("\nğŸš€ å¼€å§‹çˆ¬å–FOFAæ–°IP...")
           new_ips = crawl_fofa_with_cookie_simple()
       
           if new_ips:
               ip_info_list = []
               for ip in new_ips:
                   ip_info_list.append((ip, "", 0))
               process_new_ips(ip_info_list)
           else:
               print("âŒ æ²¡æœ‰è·å–åˆ°æ–°IP")
       
           print("\nğŸ“º å¼€å§‹ç”Ÿæˆé¢‘é“æ–‡ä»¶...")
           generate_channel_files()
       
           print("\n" + "=" * 60)
           print("ğŸ‰ ä»»åŠ¡å®Œæˆï¼")
           print("=" * 60)
       
       
       if __name__ == "__main__":
           main()
       EOF
    - name: æäº¤æ›´æ–°
      run: |
        cd $GITHUB_WORKSPACE
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add .
        git commit -m "æ›´æ–°é…’åº—æºip"
        git push
